<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <title>HEX | Khantober</title>
        
        <!-- turn off scroll bars -->
        <style>
            body {
                overflow: hidden;
            }

            canvas {
                position: absolute;
                left: 0px;
                top: 0px;
            }
        </style>
        
		<!-- canvas tag -->
        <canvas id="canvas"></canvas>
        
        <!-- set up HTML canvas -->
        <script>
            var canvas = document.getElementById("canvas");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            var width = canvas.width, height = canvas.height;
            var ctx = canvas.getContext("2d");
        </script>
        
        <!-- functions for drawing on the canvas -->
        <script>
            // convert to hexadecimal
			var toHex = function(num){
				var chars = "0123456789ABCDEF";
				
				return chars[(num-(num%16))/16]+chars[num%16];
			};
            
            // make colors
			var color = function(r, g, b, a){
				if(g === undefined && b === undefined && a === undefined){
					g = r;
					b = r;
					a = 255;
				}
				if(b === undefined && a === undefined){
					a = g;
					g = r;
					b = r;
				}
				if(a === undefined){
					a = 255;
				}
				
				ctx.globalAlpha = a/255;
				return "#"+toHex(r)+toHex(g)+toHex(b);
			};
			var fill = function(r, g, b, a){
				if(typeof r === "string"){
					ctx.fillStyle = r;
				}
				
				else{
					if(g === undefined && b === undefined && a === undefined){
						g = r;
						b = r;
						a = 255;
					}
					if(b === undefined && a === undefined){
						a = g;
						g = r;
						b = r;
					}
					if(a === undefined){
						a = 255;
					}
					
					ctx.globalAlpha = a/255;
					ctx.fillStyle = "#"+toHex(r)+toHex(g)+toHex(b);
				}
			};
			var stroke = function(r, g, b){
				if(typeof r === "string"){
					ctx.strokeStyle = r;
				}
				
				else{
					if(g === undefined || b === undefined){
						g = r;
						b = r;
					}
					
					ctx.strokeStyle = "#"+toHex(r)+toHex(g)+toHex(b);
				}
			};
			
			// arcs and ellipses
			var arc = function(x, y, w, h, start, stop){
			    if(w < 0){
			        w = 0;
			    }
			    
                ctx.save();
                ctx.translate(x, y);
                ctx.scale(1, h/w);
                
                ctx.beginPath();
                ctx.arc(0, 0, w/2, start, angle(stop));
                ctx.fill();
                
                ctx.restore();
            }
            var ellipse = function(x, y, w, h){
                arc(x, y, w, h, 0, 360)
            }
        </script>
        
        <!-- helpful math functions -->
        <script>
            
            // the square roots of two and three
            var rt2 = Math.sqrt(2), rt3 = Math.sqrt(3);
            
            // convert an angle to radians
            var angle = function(theta){
                return theta * Math.PI / 180;
            };
            
            // sin and cos in degrees
            var sin = function(theta){
                return Math.sin(theta * Math.PI / 180);
            };
            var cos = function(theta){
                return Math.cos(theta * Math.PI / 180);
            };
			
			// atan2 in degrees
            var atan2 = function(y, x){
                return (360 + Math.atan2(y, x) * 180 / Math.PI) % 360;
            };
            
            // lerp
            var lerp = function(num1, num2, amount){
                return num1 + (num2-num1) * amount;
            };
            
            // constrain
            var constrain = function(num, min, max){
                return num < min ? min : num > max ? max : num;
            };

            // distance squared
            var distSQ = function(x1, y1, x2, y2){
                return Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);
            };

        </script>

        <!-- open in full screen (credit to Polar @notPolar for their help with this)-->
        <script type="module">
            window.openInFullscreen = function(){
                var w = window.open();
                
                let pageCode = "";
                pageCode += "<html><head><script>";
                pageCode += "var KAInfiniteLoopProtect = function(){};";
                pageCode += "</scr" + "ipt>";
                pageCode += document.getElementsByTagName("head")[0].innerHTML;
                pageCode += "</head><body onkeydown=\"keyPressed(event)\" onkeyup=\"keyReleased(event)\" onclick=\"onClick(event)\" onmousemove=\"updateMouse(event)\" onresize=\"onResize()\">";
                pageCode += document.getElementsByTagName("body")[0].innerHTML;
                pageCode += "</body></html>";
                
                
                w.document.open();
                w.document.write(pageCode);
                w.document.close();
            };
        </script>

        <!-- fullscreen and pause buttons -->
        <script>
            
            // full screen button
            var fullScreenBtn = function(){
                ctx.save();
                ctx.translate(width - 25, height - 25);

                if(mouseX > width - 50 && mouseY > height - 50){
                    document.body.style.cursor = "pointer";
                    stroke(220);
                    
                    mouseClicked = function(){
                        window.openInFullscreen();
                    };
                }

                else{
                    document.body.style.cursor = "default";
                    
                    if(!gamePaused){
                        stroke(0);
                    }
                }
                
                let w = 30, l = 8;
                
                // fullscreen button
                ctx.globalAlpha = titleFade;

                with(ctx){
                    lineWidth = 3;

                    beginPath();

                    moveTo(-w / 2, -(w / 2 - l));
                    lineTo(-w / 2, -w / 2);
                    lineTo(-(w / 2 - l), -w / 2);

                    moveTo((w / 2 - l), -w / 2);
                    lineTo(w / 2, -w / 2);
                    lineTo(w / 2, -(w / 2 - l));

                    moveTo(w / 2, (w / 2 - l));
                    lineTo(w / 2, w / 2);
                    lineTo((w / 2 - l), w / 2);

                    moveTo(-(w / 2 - l), w / 2);
                    lineTo(-w / 2, w / 2);
                    lineTo(-w / 2, (w / 2 - l));

                    stroke();

                    lineWidth = 1;
                }
                
                ctx.globalAlpha = 1;

                ctx.restore();
            };
            
            // pause button
            var pauseBtn = function(){
                ctx.save();
                ctx.translate(width - 25, height - 25);

                if(mouseX > width - 50 && mouseY > height - 50){
                    document.body.style.cursor = "pointer";
                    fill(220);
                    
                    mouseClicked = function(){
                        gamePaused = !gamePaused;
                        
                        if(player.lvl >= tutorialIndex){
                            textIndex = 0;
                            tutorialIndex++;
                        }
                    };
                }

                else{
                    document.body.style.cursor = "default";
                    fill(0);
                }
                
                ctx.globalAlpha = 1 - titleFade;
                
                if(gamePaused){
                    ctx.beginPath();
                    ctx.moveTo(-15, -15);
                    ctx.lineTo(-15, 15);
                    ctx.lineTo(10, 0);
                    ctx.fill();
                }
                
                else{
                    ctx.fillRect(-15, -15, 10, 30);
                    ctx.fillRect(5, -15, 10, 30);
                }
                
                ctx.globalAlpha = 1;
                
                
                ctx.restore();
            };
            
        </script>

        <!-- the font -->
        <script>
            var setFont = function(size){
                ctx.font = "bold " + size + "px Calibri";
            };
        </script>

        <!-- user inputs -->
        <script>
            // some helpful keyCode variables
            var Q = 81, W = 87, E = 69, A = 65, S = 83, D = 68, UP = 38, LEFT = 37, DOWN = 40, RIGHT = 39, SHIFT = 16, SPACE = 32;

            // which keys are being held down/tapped
            var keys = [], pressed = [];
            
            // pressing a key
            var keyPressed = function(event){
                keys[event.keyCode] = true;
                pressed[event.keyCode] = true;
                
                if([UP, LEFT, DOWN, RIGHT, SPACE].indexOf(event.keyCode) > -1){
                    event.preventDefault();
                }
            };
            
            // releasing a key
            var keyReleased = function(event){
                keys[event.keyCode] = false;
            };
            
            // moving the mouse
            var mouseX, mouseY, cursor = "cross";
            var updateMouse = function(event){
                mouseX = event.clientX;
                mouseY = event.clientY;
            };
            
            // clicking the mouse
            var mouseClicked = function(){};
            var onClick = function(){
                mouseClicked();
            };
            
            // resizing the screen
            var isResize = false, scaleFactor = 900 / height;
            var onResize = function(){
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                width = canvas.width;
                height = canvas.height;

                isResize = true;

                scaleFactor = 900 / height;
            };
        </script>

        <!-- game map -->
        <script>

            // the diameter of a hex tile
            var tileSize = 350;

            // the grid that keeps track of which hexes are occupied
            var gameMap = [];

            // draws a hex tile
            var drawTile = function(x, y, t){
                ctx.save();
                ctx.translate(x, y);

                stroke(40, 150, 40);
                fill(50, 200, 50);

                with(ctx){
                    beginPath();

                    moveTo(-tileSize / 2, 0);
                    lineTo(-tileSize / 4, -tileSize / 4);
                    lineTo(tileSize / 4, -tileSize / 4);
                    lineTo(tileSize / 2, 0);
                    lineTo(tileSize / 4, tileSize / 4);
                    lineTo(-tileSize / 4, tileSize / 4);
                    lineTo(-tileSize / 2, 0);

                    fill();
                    stroke();
                }

                // little piles of pebbles
                let rock1 = function(x, y, s){
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.scale(s, Math.abs(s));

                    fill(80);
                    ellipse(0, -5, 12, 10);

                    fill(120);
                    ellipse(5, 0, 8, 5);

                    fill(100);
                    ellipse(-10, 2, 4, 3);

                    ctx.restore();
                };
                let rock2 = function(x, y, s){
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.scale(s, Math.abs(s));

                    fill(150);
                    ellipse(0, -2, 15, 5);

                    fill(100);
                    ellipse(8, -6, 5, 3);

                    fill(120);
                    ellipse(2, 1, 6, 4);

                    ctx.restore();
                };
                let rock3 = function(x, y, s){
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.scale(s, Math.abs(s));

                    fill(130);
                    ellipse(0, -5, 10, 8);

                    fill(80);
                    ellipse(-5, -2, 4, 4);

                    fill(100);
                    ellipse(7, 1, 6, 5);

                    ctx.restore();
                };

                // plants
                let plant1 = function(x, y, s){
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.scale(s, Math.abs(s));

                    let leaf = function(x, y, r, s){
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.scale(s, Math.abs(s));
                        ctx.rotate(angle(r));

                        with(ctx){
                            beginPath();

                            moveTo(0, 0);
                            bezierCurveTo(0, -5, -5, -10, 0, -20);
                            bezierCurveTo(5, -10, 0, -5, 0, 0);

                            fill();
                        }

                        ctx.restore();
                    };

                    fill(0, 100, 50);
                    leaf(0, 0, 0, 1.2);

                    fill(0, 120, 50);
                    leaf(0, 0, -30, 1);

                    fill(0, 150, 50);
                    leaf(0, 0, 35, 0.9);

                    ctx.restore();
                };
                let plant2 = function(x, y, s){
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.scale(s, Math.abs(s));

                    fill(0, 150, 0);
                    with(ctx){
                        beginPath();

                        moveTo(-3, 0);
                        bezierCurveTo(-5, -5, -10, -5, -10, -5);
                        bezierCurveTo(-10, -7, -3, -5, -2, 0);
                        fill();

                        beginPath();
                        moveTo(-1, 0);
                        bezierCurveTo(-5, -5, -6, -10, -9, -10);
                        bezierCurveTo(-6, -12, -1, -5, 1, 0);
                        fill();

                        beginPath();
                        moveTo(-3, 0);
                        bezierCurveTo(-3, -5, -3, -10, -5, -20);
                        bezierCurveTo(0, -10, 0, -5, 0, 0);
                        fill();

                        beginPath();
                        moveTo(-1, 0);
                        bezierCurveTo(-1, -5, -2, -15, 8, -20);
                        bezierCurveTo(0, -10, 2, -5, 2, 0);
                        fill();

                        beginPath();
                        moveTo(-1, 0);
                        bezierCurveTo(1, -5, 5, -10, 10, -10);
                        bezierCurveTo(5, -8, 3, -5, 2, 0);

                        fill();
                    }

                    ctx.restore();
                };

                switch(t){
                    case 0:
                        plant2(10, -40, 1);
                        plant1(-30, 30, 1);
                        rock2(60, 60, 1);
                    break;

                    case 1:
                        plant1(30, -40, 0.8);
                        plant2(-65, 40, 1);
                        rock1(100, 0, 0.8);
                    break;

                    case 2:
                        rock3(-20, -60, 1);
                        rock2(80, 40, 1);
                        plant1(-40, 70, 0.9);
                    break;

                    case 3:
                        plant2(10, -50, 0.8);
                        rock1(120, -20, 1);
                        rock3(-120, 20, 1);
                    break;
                }

                fill(50, 200, 50, 200);
                with(ctx){
                    beginPath();

                    moveTo(-tileSize / 2, 0);
                    lineTo(-tileSize / 4, -tileSize / 4);
                    lineTo(tileSize / 4, -tileSize / 4);
                    lineTo(tileSize / 2, 0);
                    lineTo(tileSize / 4, tileSize / 4);
                    lineTo(-tileSize / 4, tileSize / 4);
                    lineTo(-tileSize / 2, 0);

                    fill();
                    stroke();
                }

                ctx.restore();
            };

            // finds the map tile indices at a set of coords
            var findMapPos = function(x, y){
                let sz = (gameMap.length - 1) / 2;
                    j = sz + Math.round(x / (tileSize * 0.75)),
                    i = sz + Math.round((y - tileSize * rt3 / 4 + (j % 2 ? 0 : 1) * tileSize * rt3 / 4) / (tileSize * rt3 / 2));
                
                return {j: j, i: i};
            };

            // finds the coords of a set of map tile indices
            var findCoords = function(j, i){

                // distance from the edge of the map to the center
                let sz = (gameMap.length - 1) / 2;

                // x- and y-positions
                let x = (j - sz) * tileSize * 0.75,
                    y = (i - sz) * tileSize / 2 + ((j - sz) % 2 ? 1 : 0) * tileSize / 4;
                
                return {x: x, y: y * rt3};
            };

            // generates a "random" but consistent number given an x and y input
            var genTileNum = function(j, i){
                let outX = (Math.sin(j * 1001) + Math.cos(j * 1891)) / 2;
                let outY = (Math.sin(i * 1011) + Math.cos(i * 1901)) / 2;
                
                return (2 + outX + outY) / 4;
            }

            // draws the map
            var drawMap = function(){

                // distance from the edge of the map to the center
                let sz = (gameMap.length - 1) / 2;

                // draw all the tiles
                for(let i = 0; i < gameMap.length; i++){
                    for(let j = 0; j < gameMap[i].length; j++){
                        let coords = findCoords(j, i),
                            tileNum = Math.floor(genTileNum(j, i) * 4);
                        
                        drawTile(coords.x, coords.y / rt3, tileNum);
                    }
                }

                // draw the player's build marker
                let mapPos = findMapPos(player.x, player.y),
                    buildPos = findCoords(mapPos.j, mapPos.i);

                if(gameMap[mapPos.i][mapPos.j] !== "1"){
                    fill(0, 20);
                    with(ctx){
                        save();
                        translate(buildPos.x, buildPos.y / rt3);

                        beginPath();

                        moveTo(-tileSize / 2, 0);
                        lineTo(-tileSize / 4, -tileSize / 4);
                        lineTo(tileSize / 4, -tileSize / 4);
                        lineTo(tileSize / 2, 0);
                        lineTo(tileSize / 4, tileSize / 4);
                        lineTo(-tileSize / 4, tileSize / 4);

                        fill();

                        restore();
                    }
                }

                // add black around the edges
                fill(0);
                let xLimit = tileSize * 0.75 * sz,
                    yLimit = tileSize * 0.5 * sz;
                
                ctx.fillRect(-xLimit - width, -yLimit - height, 2 * xLimit + 2 * width, height);
                ctx.fillRect(-xLimit - width, yLimit + tileSize / 4, 2 * xLimit + 2 * width, height);
                ctx.fillRect(-xLimit - width, -yLimit, width, 2 * yLimit + tileSize / 4);
                ctx.fillRect(xLimit, -yLimit, width, 2 * yLimit + tileSize / 4);

            };

        </script>

        <!-- gameplay variables -->
        <script>

            // reset the game between rounds
            var resetGame = function(){
                
                // player
                player.x = 0;
                player.y = tileSize * rt3 / 2;

                player.px = player.x;
                player.py = player.y;

                player.vel.x = 0;
                player.vel.y = 0;

                player.dir = {x: 0, y: 1};
                player.r = 90;

                player.action = "stand";

                player.maxHealth = 100;
                player.health = player.maxHealth;

                player.maxSpeed = 8;
                player.speed = player.maxSpeed;

                player.gold = 25;
                player.xp = 0;
                player.lvl = 0;

                player.frozen = 0;

                player.score = 0;

                player.stand();

                // castle
                castle.x = 0;
                castle.y = 0;
                castle.health = castle.maxHealth;

                // misc.
                entities = [castle, player];

                gameStarted = false;

                gameMap = [
                    "-------------",
                    "-------------",
                    "-------------",
                    "-------------",
                    "-------------",
                    "-------------",
                    "------1------",
                    "-------------",
                    "-------------",
                    "-------------",
                    "-------------",
                    "-------------",
                    "-------------"
                ];

                titleFade = 1;

                delag = false;
            };

            // spawns enemies
            var enemySpawn = true, spawnCool = 0;
            var spawnEnemies = function(){

                // size of the map
                let sz = (gameMap.length - 1) / 2;

                // limit for spawnable space
                let xLimit = tileSize * 0.75 * sz - 100,
                    yLimit = tileSize * rt3 / 2 * sz - 100;
                
                // spawn rate in spawns per second
                let spawnRate = 0.25;

                // spawn enemies when cooldown finishes
                if(spawnCool === 0){
                    spawnCool = Math.round(60 / spawnRate);

                    // calculate spawn position
                    let spawnX = -xLimit + Math.random() * xLimit * 2,
                        spawnY = -yLimit + Math.random() * yLimit * 2 + tileSize / 4;

                    if(Math.abs(spawnX) > Math.abs(spawnY)){
                        spawnX = spawnX < 0 ? -xLimit : xLimit;
                    }

                    else{
                        spawnY = spawnY < 0 ? -yLimit : yLimit + tileSize / 4;
                    }

                    // calculate number of enemies to spawn (probability of higher spawn number increases with level)
                    let numSpawns = 1 + Math.floor(Math.pow(player.lvl * Math.random(), 0.8));

                    // possible spawn types
                    let spawnTypes = [Goblin, Archer, Troll, Bomber, Miner, Alpha];

                    // relative likelihood of each spawn type
                    let spawnWeights = [
                        1, // goblin
                        player.lvl < 2 ? 0 : 0.8, // archer
                        player.lvl < 3 ? 0 : 0.2 + (player.lvl - 3) * 0.1, // troll
                        player.lvl < 5 ? 0 : 0.2 + (player.lvl - 5) * 0.1, // bomber
                        player.lvl < 7 ? 0 : 0.2 + (player.lvl - 7) * 0.1, // miner
                        player.lvl < 15 ? 0 : 0.2 + (player.lvl - 15) * 0.1 // alpha
                    ];

                    // total weight
                    let totalWeight = (function(){
                        let sum = 0;
                        for(let i = 0; i < spawnWeights.length; i++){
                            sum += spawnWeights[i];
                        }
                        return sum;
                    })();

                    // for each enemy spawned...
                    for(let i = 0; i < numSpawns; i++){

                        // calculate the type of enemy to spawn (difficulty increases with level)
                        let randomNum = Math.random(), curWeight = 0, spawnType;
                        for(let j = 0; j < spawnWeights.length; j++){
                            if(randomNum < curWeight / totalWeight){
                                break;
                            }

                            curWeight += spawnWeights[j];
                            spawnType = spawnTypes[j];
                        }

                        // spawn that enemy
                        addEntity(new spawnType(spawnX - 50 + Math.random() * 100, spawnY - 50 + Math.random() * 100));

                    }
                }

                // increment cooldown
                spawnCool--;

            };
        
            // whether or not the game has started
            var gameStarted = false;

            // whether or not the game is paused
            var gamePaused = false;

            // fade out the title
            var titleFade = 1;

            // screen shake
            var shakeX = 0;
            var shakeScreen = function(amt){
                shakeX = (Math.sign(shakeX) || 1) * amt;
            };

        </script>

        <!-- game pausing & tutorial -->
        <script>
            
            var tutorialIndex = 0,
            tutorialText = [
                "Use the arrow keys or WASD to move, and press the spacebar to attack. Defend your castle from the marauding goblins! Click to continue.",
                "Gold is useful for building towers! Once you've collected 50 gold, press and hold 1 to build an arrow tower.",
                "All enemies drop experience! Gain experience to level up and unlock new towers. Press and hold 2 to build a ballista tower. That's it from me. Good luck!"
            ],
            textIndex = 0,
            tutorial = function(){
                if(player.lvl >= tutorialIndex && tutorialIndex < tutorialText.length){
                    gamePaused = true;
                }

                if(gamePaused && player.lvl >= tutorialIndex && tutorialIndex < tutorialText.length){
                    if(textIndex < tutorialText[tutorialIndex].length){
                        textIndex++;
                    }

                    let writeText = function(txt, x, y, w){
                        let lineStart = 0, wordStart = 0, lines = [];
                        for(let i = 0; i < txt.length; i++){
                            let curLine = txt.slice(lineStart, i); 

                            if(txt[i] === " " || txt[i] === "\n"){
                                wordStart = i + 1;
                            }

                            if(txt[i] === "\n" || ctx.measureText(curLine).width > w){
                                lines.push(txt.slice(lineStart, wordStart));
                                lineStart = wordStart;
                            }

                            else if(i === txt.length - 1){
                                lines.push(txt.slice(lineStart, txt.length));
                            }
                        }

                        for(let i = 0; i < lines.length; i++){
                            ctx.fillText(lines[i], x, y + i * 40);
                        }
                    };

                    fill(0);
                    setFont(30);
                    writeText(tutorialText[tutorialIndex].slice(0, textIndex), 100, 100, width - 200);

                    mouseClicked = function(){
                        if(textIndex < tutorialText[tutorialIndex].length){
                            textIndex = tutorialText[tutorialIndex].length;
                        }

                        else{
                            gamePaused = false;
                            textIndex = 0;
                            tutorialIndex++;
                        }
                    };
                    
                    if(pressed[SHIFT]){
                        if(textIndex < tutorialText[tutorialIndex].length){
                            textIndex = tutorialText[tutorialIndex].length;
                        }

                        else{
                            gamePaused = false;
                            textIndex = 0;
                            tutorialIndex++;
                        }
                    }
                }
                
                else if(gamePaused){
                    fill(0);
                    setFont(50);
                    let m = "P A U S E D", tw = ctx.measureText(m).width;
                    ctx.fillText(m, width / 2 - tw / 2, height / 2 - 70);
                    
                    setFont(20);
                    m = "Click to Resume", tw = ctx.measureText(m).width;
                    ctx.fillText(m, width / 2 - tw / 2, height / 2 + 40);
                    
                    mouseClicked = function(){
                        gamePaused = false;
                    };
                }
            };
        </script>

        <!-- towers -->
        <script>
            var ArrowTower = function(x, y){

                // entity type
                this.type = "tower";

                // whether or not it can move
                this.mobile = false;

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;

                // size
                this.sz = 80;

                // stats
                this.health = 200; // health
                this.maxHealth = 200; // maximum health
                this.cool = 0; // current time until next attack
                this.maxCool = 20; // attack cooldown
                this.range = 400; // attack range

            };
            ArrowTower.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3);

                if(this.health > 0){
                
                    // base
                    fill(150);

                    with(ctx){
                        beginPath();

                        moveTo(-40, 0);
                        lineTo(-40, -100);
                        lineTo(40, -100);
                        lineTo(40, 0);

                        fill();
                    }

                    arc(0, 0, 80, 80 / rt3, 0, 180);

                    // shadows
                    for(let i = 0; i < 20; i++){
                        fill(0, 60 - i * 3);
                        // fill(0, 50);
                        ctx.fillRect(i - 40, -100, 1, 101 + 40 * Math.sin(Math.acos((40 - i) / 40)) / rt3);
                    }

                    ctx.globalAlpha = 1;

                    // arrow slots
                    ctx.lineWidth = 2;
                    stroke(50);

                    with(ctx){
                        beginPath();
                        moveTo(30, -40);
                        lineTo(30, -20);
                        stroke();

                        beginPath();
                        moveTo(25, -28);
                        lineTo(35, -32);
                        stroke();

                        beginPath();
                        moveTo(0, -35);
                        lineTo(0, -15);
                        stroke();

                        beginPath();
                        moveTo(-5, -25);
                        lineTo(5, -25);
                        stroke();

                        beginPath();
                        moveTo(-30, -40);
                        lineTo(-30, -20);
                        stroke();

                        beginPath();
                        moveTo(-35, -32);
                        lineTo(-25, -28);
                        stroke();
                    }

                    ctx.lineWidth = 1;

                    // the roof
                    fill(0, 80, 180);

                    with(ctx){
                        beginPath();

                        moveTo(-50, -100);
                        lineTo(0, -170);
                        lineTo(50, -100);
                        lineTo(50, -99);
                        lineTo(-50, -99);

                        fill();
                    }

                    arc(0, -100, 100, 100 / rt3, 0, 180);

                    // shadows
                    fill(0, 20);

                    with(ctx){
                        beginPath();

                        moveTo(0, -170);
                        bezierCurveTo(-50, -100, -0, -60, 50, -100);
                        bezierCurveTo(45, -60, -45, -60, -50, -100);

                        fill();
                    }

                    ctx.globalAlpha = 1;

                    // health bar
                    if(this.health < this.maxHealth){
                        fill(0);
                        ctx.fillRect(-50, -200, 100, 6);
                        
                        fill(200, 0, 0);
                        ctx.fillRect(-50, -200, this.health * 100 / this.maxHealth, 6);
                    }

                }
                
                // destroyed tower
                else{

                    fill(120);
                    with(ctx){
                        beginPath();

                        moveTo(-40, 0);
                        lineTo(-40, -50);
                        lineTo(-35, -55);
                        lineTo(-25, -45);
                        lineTo(-15, -40);
                        lineTo(-5, -40);
                        lineTo(10, -30);
                        lineTo(15, -35);
                        lineTo(25, -40);
                        lineTo(30, -30);
                        lineTo(35, -25);
                        lineTo(40, -20);
                        lineTo(40, 0);

                        fill();
                    }

                    fill(100);
                    ellipse(0, 0, 80, 80 / rt3);

                    fill(150);
                    with(ctx){
                        beginPath();

                        moveTo(-40, 1);
                        lineTo(-40, -50);
                        lineTo(-30, -45);
                        lineTo(-20, -20);
                        lineTo(-10, -10);
                        lineTo(-5, 0);
                        lineTo(15, -10);
                        lineTo(25, 0);
                        lineTo(30, -10);
                        lineTo(40, -20);
                        lineTo(40, 1);

                        fill();
                    }

                    arc(0, 0, 80, 80 / rt3, 0, 180);

                    // shadows
                    for(let i = 0; i < 20; i++){
                        let yOff = i < 10 ? i / 2 : 5 + (i - 10) * 2;

                        fill(0, 60 - i * 3);
                        ctx.fillRect(i - 40, -50 + yOff, 1, 51 - yOff + 40 * Math.sin(Math.acos((40 - i) / 40)) / rt3);
                    }

                    ctx.globalAlpha = 1;
                }

                ctx.restore();
            };
            ArrowTower.prototype.update = function(){
                
                if(this.health > 0){

                    // if the attack cooldown is finished...
                    if(this.cool === 0){

                        // check for the closest enemy
                        let closest, dist = Math.pow(10, 8);
                        for(let i = 0; i < entities.length; i++){
                            let en = entities[i];

                            // only target enemies
                            if(en.type !== "enemy"){
                                continue;
                            }

                            // the distance to the current enemy
                            let curDist = distSQ(this.x, this.y, en.x, en.y);

                            // if the enemy is within range and is closer than the previouly found enemy
                            if(curDist <= Math.pow(this.range, 2) && curDist < dist){
                                dist = curDist;
                                closest = en;
                            }
                        }

                        // if we've found an enemy, attack it
                        if(closest){
                            let r = atan2(closest.y - this.y, closest.x - this.x);
                            let arrow = new Arrow(this.x + this.sz * cos(r) / 2, this.y + this.sz * sin(r) / 2, -30, closest);
                            addEntity(arrow);

                            this.cool = this.maxCool;
                        }
                    }

                    // otherwise, update attack cooldown
                    else{
                        this.cool--;
                    }
                }
            
                else{

                    // make the spot buildable again
                    let mapPos = findMapPos(this.x, this.y);

                    if(gameMap[mapPos.i][mapPos.j] === "1"){
                        gameMap[mapPos.i] = gameMap[mapPos.i].slice(0, mapPos.j) + "-" + gameMap[mapPos.i].slice(mapPos.j + 1, gameMap[mapPos.i].length);
                    }

                    // if the player is on the current tile...
                    let playerPos = findMapPos(player.x, player.y);
                    if(mapPos.j === playerPos.j && mapPos.i === playerPos.i){

                        // check if they're trying to build something
                        let building = false;

                        for(let i = 0; i < player.towerButtons.length; i++){
                            let btn = player.towerButtons[i];

                            if(keys[btn.key] && player.gold >= player.costOf(btn.towerType)){
                                building = true;
                                break;
                            }
                        }

                        // if they are, remove this tower
                        if(building){
                            this.on = false;
                        }
                    }
                }

            };

            var CannonTower = function(x, y){

                // entity type
                this.type = "tower";

                // whether or not it can move
                this.mobile = false;

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;

                // size
                this.sz = 80;

                // stats
                this.health = 200; // health
                this.maxHealth = 200; // maximum health
                this.cool = 0; // current time until next attack
                this.maxCool = 60; // attack cooldown
                this.range = 500; // attack range

            };
            CannonTower.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3);

                if(this.health > 0){
                    
                    // base
                    fill(150);

                    with(ctx){
                        beginPath();

                        moveTo(-40, 0);
                        lineTo(-40, -100);
                        lineTo(40, -100);
                        lineTo(40, 0);

                        fill();
                    }

                    arc(0, 0, 80, 80 / rt3, 0, 180);

                    // shadows
                    for(let i = 0; i < 20; i++){
                        fill(0, 60 - i * 3);
                        // fill(0, 50);
                        ctx.fillRect(i - 40, -100, 1, 101 + 40 * Math.sin(Math.acos((40 - i) / 40)) / rt3);
                    }

                    ctx.globalAlpha = 1;

                    // left cannon
                    fill(80);
                    with(ctx){
                        beginPath();
                        moveTo(-40, -45);
                        lineTo(-30, -35);
                        lineTo(-30, -15);
                        lineTo(-40, -25);
                        fill();
                    }

                    fill(40);
                    with(ctx){
                        beginPath();
                        moveTo(-30, -32);
                        lineTo(-45, -37);
                        lineTo(-45, -25);
                        lineTo(-30, -20);
                        fill();
                    }
                    ellipse(-45, -31, 8, 12);

                    fill(0, 0, 40);
                    ellipse(-45, -31, 4, 6);

                    // middle cannon
                    fill(80);
                    with(ctx){
                        beginPath();
                        moveTo(-9, -33);
                        lineTo(9, -33);
                        lineTo(9, -13);
                        lineTo(-9, -13);
                        fill();
                    }

                    fill(40);
                    ctx.fillRect(-6, -20, 12, 5);
                    ellipse(0, -20, 12, 12);
                    ellipse(0, -15, 12, 12);

                    fill(0, 0, 0, 40);
                    ellipse(0, -15, 6, 6);

                    // right cannon
                    fill(80);
                    with(ctx){
                        beginPath();
                        moveTo(40, -45);
                        lineTo(30, -35);
                        lineTo(30, -15);
                        lineTo(40, -25);
                        fill();
                    }

                    fill(40);
                    with(ctx){
                        beginPath();
                        moveTo(30, -32);
                        lineTo(45, -37);
                        lineTo(45, -25);
                        lineTo(30, -20);
                        fill();
                    }
                    ellipse(45, -31, 8, 12);

                    fill(0, 0, 40);
                    ellipse(45, -31, 4, 6);

                    // the roof
                    fill(200, 80, 50);

                    with(ctx){
                        beginPath();

                        moveTo(-50, -100);
                        lineTo(0, -170);
                        lineTo(50, -100);
                        lineTo(50, -99);
                        lineTo(-50, -99);

                        fill();
                    }

                    arc(0, -100, 100, 100 / rt3, 0, 180);

                    // shadows
                    fill(0, 20);

                    with(ctx){
                        beginPath();

                        moveTo(0, -170);
                        bezierCurveTo(-50, -100, -0, -60, 50, -100);
                        bezierCurveTo(45, -60, -45, -60, -50, -100);

                        fill();
                    }

                    ctx.globalAlpha = 1;

                    // health bar
                    if(this.health < this.maxHealth){
                        fill(0);
                        ctx.fillRect(-50, -200, 100, 6);
                        
                        fill(200, 0, 0);
                        ctx.fillRect(-50, -200, this.health * 100 / this.maxHealth, 6);
                    }

                }

                // destroyed tower
                else{

                    fill(120);
                    with(ctx){
                        beginPath();

                        moveTo(-40, 0);
                        lineTo(-40, -50);
                        lineTo(-35, -55);
                        lineTo(-25, -45);
                        lineTo(-15, -40);
                        lineTo(-5, -40);
                        lineTo(10, -30);
                        lineTo(15, -35);
                        lineTo(25, -40);
                        lineTo(30, -30);
                        lineTo(35, -25);
                        lineTo(40, -20);
                        lineTo(40, 0);

                        fill();
                    }

                    fill(100);
                    ellipse(0, 0, 80, 80 / rt3);

                    fill(150);
                    with(ctx){
                        beginPath();

                        moveTo(-40, 1);
                        lineTo(-40, -50);
                        lineTo(-30, -45);
                        lineTo(-20, -20);
                        lineTo(-10, -10);
                        lineTo(-5, 0);
                        lineTo(15, -10);
                        lineTo(25, 0);
                        lineTo(30, -10);
                        lineTo(40, -20);
                        lineTo(40, 1);

                        fill();
                    }

                    arc(0, 0, 80, 80 / rt3, 0, 180);

                    // shadows
                    for(let i = 0; i < 20; i++){
                        let yOff = i < 10 ? i / 2 : 5 + (i - 10) * 2;

                        fill(0, 60 - i * 3);
                        ctx.fillRect(i - 40, -50 + yOff, 1, 51 - yOff + 40 * Math.sin(Math.acos((40 - i) / 40)) / rt3);
                    }

                    ctx.globalAlpha = 1;
                }

                ctx.restore();
            };
            CannonTower.prototype.update = function(){

                if(this.health > 0){

                    // if the attack cooldown is finished...
                    if(this.cool === 0){

                        // check for the closest enemy
                        let closest, dist = Math.pow(10, 8);
                        for(let i = 0; i < entities.length; i++){
                            let en = entities[i];

                            // only target enemies
                            if(en.type !== "enemy"){
                                continue;
                            }

                            // the distance to the current enemy
                            let curDist = distSQ(this.x, this.y, en.x, en.y);

                            // if the enemy is within range and is closer than the previouly found enemy
                            if(curDist <= Math.pow(this.range, 2) && curDist < dist){
                                dist = curDist;
                                closest = en;
                            }
                        }

                        // if we've found an enemy, attack it
                        if(closest){
                            let r = atan2(closest.y - this.y, closest.x - this.x);
                            let bomb = new Bomb(this.x + this.sz * cos(r) / 2, this.y + this.sz * sin(r) / 2, -30, closest);
                            addEntity(bomb);

                            this.cool = this.maxCool;
                        }
                    }

                    // otherwise, update attack cooldown
                    else{
                        this.cool--;
                    }
                }
            
                else{

                    // make the spot buildable again
                    let mapPos = findMapPos(this.x, this.y);

                    if(gameMap[mapPos.i][mapPos.j] === "1"){
                        gameMap[mapPos.i] = gameMap[mapPos.i].slice(0, mapPos.j) + "-" + gameMap[mapPos.i].slice(mapPos.j + 1, gameMap[mapPos.i].length);
                    }

                    // if the player is on the current tile...
                    let playerPos = findMapPos(player.x, player.y);
                    if(mapPos.j === playerPos.j && mapPos.i === playerPos.i){

                        // check if they're trying to build something
                        let building = false;

                        for(let i = 0; i < player.towerButtons.length; i++){
                            let btn = player.towerButtons[i];

                            if(keys[btn.key] && player.gold >= player.costOf(btn.towerType)){
                                building = true;
                                break;
                            }
                        }

                        // if they are, remove this tower
                        if(building){
                            this.on = false;
                        }
                    }
                }

            };

            var BallistaTower = function(x, y){

                // entity type
                this.type = "tower";

                // whether or not it can move
                this.mobile = false;

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;

                // size
                this.sz = 80;

                // stats
                this.health = 200; // health
                this.maxHealth = 200; // maximum health
                this.cool = 0; // current time until next attack
                this.maxCool = 100; // attack cooldown
                this.range = 600; // attack range
            };
            BallistaTower.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3);
                
                if(this.health > 0){

                    // base
                    fill(150);

                    with(ctx){
                        beginPath();

                        moveTo(-40, 0);
                        lineTo(-40, -100);
                        lineTo(40, -100);
                        lineTo(40, 0);

                        fill();
                    }

                    arc(0, 0, 80, 80 / rt3, 0, 180);

                    // shadows
                    for(let i = 0; i < 20; i++){
                        fill(0, 60 - i * 3);
                        // fill(0, 50);
                        ctx.fillRect(i - 40, -100, 1, 101 + 40 * Math.sin(Math.acos((40 - i) / 40)) / rt3);
                    }

                    ctx.globalAlpha = 1;

                    // left ballista
                    fill(50);
                    with(ctx){
                        beginPath();

                        moveTo(-36, -29);
                        bezierCurveTo(-37, -50, -30, -48, -31, -24);

                        fill();
                    }

                    fill(150, 75, 0);
                    with(ctx){
                        beginPath();

                        moveTo(-35, -30);
                        lineTo(-55, -25);
                        lineTo(-52, -22);
                        lineTo(-32, -27);

                        fill();

                        beginPath();

                        moveTo(-55, -37);
                        bezierCurveTo(-60, -25, -53, -17, -35, -15);
                        bezierCurveTo(-51, -22, -54, -25, -55, -37);

                        fill();
                    }

                    stroke(50);
                    with(ctx){
                        beginPath();

                        moveTo(-33.5, -28.5);
                        lineTo(-55, -37);

                        moveTo(-33.5, -28.5);
                        lineTo(-35, -15);

                        stroke();
                    }

                    ctx.lineWidth = 2;
                    stroke(0);
                    with(ctx){
                        beginPath();
                        moveTo(-33.5, -28.5);
                        lineTo(-53.5, -23.5);
                        stroke();
                    }

                    ctx.lineWidth = 1;

                    fill(0);
                    with(ctx){
                        beginPath();

                        moveTo(-59.5, -22.5);
                        lineTo(-56, -26);
                        lineTo(-51, -21);

                        fill();
                    }

                    // middle ballista
                    fill(50);
                    with(ctx){
                        beginPath();
                        moveTo(-5, -20);
                        bezierCurveTo(-5, -42, 5, -42, 5, -20);fill();
                    }

                    fill(150, 75, 0);
                    ctx.fillRect(-3, -25, 6, 13);
                    with(ctx){
                        beginPath();

                        moveTo(-20, -15);
                        bezierCurveTo(-8, -7, 8, -7, 20, -15);
                        bezierCurveTo(5, -13, -5, -13, -20, -15);

                        fill();
                    }

                    stroke(50);
                    with(ctx){
                        beginPath();

                        moveTo(0, -25);
                        lineTo(-20, -15);

                        moveTo(0, -25);
                        lineTo(20, -15);

                        stroke();
                    }

                    ctx.lineWidth = 2;
                    stroke(0);
                    with(ctx){
                        beginPath();
                        moveTo(0, -25);
                        lineTo(0, -10);
                        stroke();
                    }

                    ctx.lineWidth = 1;

                    fill(0);
                    with(ctx){
                        beginPath();

                        moveTo(0, -5);
                        lineTo(-5, -10);
                        lineTo(5, -10);

                        fill();
                    }

                    // right ballista
                    fill(50);
                    with(ctx){
                        beginPath();

                        moveTo(36, -29);
                        bezierCurveTo(37, -50, 30, -48, 31, -24);

                        fill();
                    }

                    fill(150, 75, 0);
                    with(ctx){
                        beginPath();

                        moveTo(35, -30);
                        lineTo(55, -25);
                        lineTo(52, -22);
                        lineTo(32, -27);

                        fill();

                        beginPath();

                        moveTo(55, -37);
                        bezierCurveTo(60, -25, 53, -17, 35, -15);
                        bezierCurveTo(51, -22, 54, -25, 55, -37);

                        fill();
                    }

                    stroke(50);
                    with(ctx){
                        beginPath();

                        moveTo(33.5, -28.5);
                        lineTo(55, -37);

                        moveTo(33.5, -28.5);
                        lineTo(35, -15);

                        stroke();
                    }

                    ctx.lineWidth = 2;
                    stroke(0);
                    with(ctx){
                        beginPath();
                        moveTo(33.5, -28.5);
                        lineTo(53.5, -23.5);
                        stroke();
                    }

                    ctx.lineWidth = 1;

                    fill(0);
                    with(ctx){
                        beginPath();

                        moveTo(59.5, -22.5);
                        lineTo(56, -26);
                        lineTo(51, -21);

                        fill();
                    }

                    // the roof
                    fill(0, 120, 0);

                    with(ctx){
                        beginPath();

                        moveTo(-50, -100);
                        lineTo(0, -170);
                        lineTo(50, -100);
                        lineTo(50, -99);
                        lineTo(-50, -99);

                        fill();
                    }

                    arc(0, -100, 100, 100 / rt3, 0, 180);

                    // shadows
                    fill(0, 20);

                    with(ctx){
                        beginPath();

                        moveTo(0, -170);
                        bezierCurveTo(-50, -100, -0, -60, 50, -100);
                        bezierCurveTo(45, -60, -45, -60, -50, -100);

                        fill();
                    }

                    ctx.globalAlpha = 1;

                    // health bar
                    if(this.health < this.maxHealth){
                        fill(0);
                        ctx.fillRect(-50, -200, 100, 6);
                        
                        fill(200, 0, 0);
                        ctx.fillRect(-50, -200, this.health * 100 / this.maxHealth, 6);
                    }

                }

                // destroyed tower
                else{

                    fill(120);
                    with(ctx){
                        beginPath();

                        moveTo(-40, 0);
                        lineTo(-40, -50);
                        lineTo(-35, -55);
                        lineTo(-25, -45);
                        lineTo(-15, -40);
                        lineTo(-5, -40);
                        lineTo(10, -30);
                        lineTo(15, -35);
                        lineTo(25, -40);
                        lineTo(30, -30);
                        lineTo(35, -25);
                        lineTo(40, -20);
                        lineTo(40, 0);

                        fill();
                    }

                    fill(100);
                    ellipse(0, 0, 80, 80 / rt3);

                    fill(150);
                    with(ctx){
                        beginPath();

                        moveTo(-40, 1);
                        lineTo(-40, -50);
                        lineTo(-30, -45);
                        lineTo(-20, -20);
                        lineTo(-10, -10);
                        lineTo(-5, 0);
                        lineTo(15, -10);
                        lineTo(25, 0);
                        lineTo(30, -10);
                        lineTo(40, -20);
                        lineTo(40, 1);

                        fill();
                    }

                    arc(0, 0, 80, 80 / rt3, 0, 180);

                    // shadows
                    for(let i = 0; i < 20; i++){
                        let yOff = i < 10 ? i / 2 : 5 + (i - 10) * 2;

                        fill(0, 60 - i * 3);
                        ctx.fillRect(i - 40, -50 + yOff, 1, 51 - yOff + 40 * Math.sin(Math.acos((40 - i) / 40)) / rt3);
                    }

                    ctx.globalAlpha = 1;
                }

                ctx.restore();
            };
            BallistaTower.prototype.update = function(){

                if(this.health > 0){

                    // if the attack cooldown is finished...
                    if(this.cool === 0){

                        // check for the closest enemy
                        let closest, dist = Math.pow(10, 8);
                        for(let i = 0; i < entities.length; i++){
                            let en = entities[i];

                            // only target enemies
                            if(en.type !== "enemy"){
                                continue;
                            }

                            // the distance to the current enemy
                            let curDist = distSQ(this.x, this.y, en.x, en.y);

                            // if the enemy is within range and is closer than the previouly found enemy
                            if(curDist <= Math.pow(this.range, 2) && curDist < dist){
                                dist = curDist;
                                closest = en;
                            }
                        }

                        // if we've found an enemy, attack it
                        if(closest){

                            let r = atan2(closest.y - this.y, closest.x - this.x);
                            let bolt = new Bolt(this.x + this.sz * cos(r) / 2, this.y + this.sz * sin(r) / 2, -30, closest);
                            addEntity(bolt);

                            this.cool = this.maxCool;
                        }
                    }

                    // otherwise, update attack cooldown
                    else{
                        this.cool--;
                    }
                }
            
                else{

                    // make the spot buildable again
                    let mapPos = findMapPos(this.x, this.y);

                    if(gameMap[mapPos.i][mapPos.j] === "1"){
                        gameMap[mapPos.i] = gameMap[mapPos.i].slice(0, mapPos.j) + "-" + gameMap[mapPos.i].slice(mapPos.j + 1, gameMap[mapPos.i].length);
                    }

                    // if the player is on the current tile...
                    let playerPos = findMapPos(player.x, player.y);
                    if(mapPos.j === playerPos.j && mapPos.i === playerPos.i){

                        // check if they're trying to build something
                        let building = false;

                        for(let i = 0; i < player.towerButtons.length; i++){
                            let btn = player.towerButtons[i];

                            if(keys[btn.key] && player.gold >= player.costOf(btn.towerType)){
                                building = true;
                                break;
                            }
                        }

                        // if they are, remove this tower
                        if(building){
                            this.on = false;
                        }
                    }
                }

            };

            var FreezeTower = function(x, y){
                
                // entity type
                this.type = "tower";

                // whether or not it can move
                this.mobile = false;

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;

                // size
                this.sz = 130;

                // stats
                this.health = 500; // health
                this.maxHealth = 500; // maximum health
                this.range = 300; // freeze range

                // freeze particles
                this.part = [];

            };
            FreezeTower.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3);

                if(this.health > 0){

                    fill(200, 220, 255, 100);
                    ellipse(0, 0, this.range * 2, this.range * 2 / rt3);

                    ctx.save();
                    ctx.translate(-4, 0);
                    ctx.scale(1.25, 1.25);

                    stroke(50, 150, 255);
                    fill(100, 180, 255);

                    with(ctx){

                        // big cube
                        beginPath();
                        moveTo(20, 20);
                        lineTo(-20, 0);
                        lineTo(-20, -40);
                        lineTo(20, -20);
                        lineTo(20, 20);
                        fill();
                        stroke();

                        beginPath();
                        moveTo(20, 20);
                        lineTo(55, 0);
                        lineTo(55, -40);
                        lineTo(20, -20);
                        lineTo(20, 20);
                        fill();
                        stroke();

                        beginPath();
                        moveTo(20, -20);
                        lineTo(-20, -40);
                        lineTo(15, -60);
                        lineTo(55, -40);
                        lineTo(20, -20);
                        fill();
                        stroke();

                        // medium cube
                        save();
                        translate(0, 5);
                        beginPath();
                        moveTo(-40, -10);
                        lineTo(-40, 15);
                        lineTo(-15, 10);
                        lineTo(-15, -15);
                        lineTo(-40, -10);
                        fill();
                        stroke();

                        beginPath();
                        moveTo(-40, -10);
                        lineTo(-40, 15);
                        lineTo(-50, 5);
                        lineTo(-50, -20);
                        lineTo(-40, -10);
                        fill();
                        stroke();

                        beginPath();
                        moveTo(-40, -10);
                        lineTo(-50, -20);
                        lineTo(-25, -25);
                        lineTo(-15, -15);
                        lineTo(-40, -10);
                        fill();
                        stroke();

                        restore();


                        // little cube
                        beginPath();
                        moveTo(-20, 28);
                        lineTo(-5, 30);
                        lineTo(-5, 15);
                        lineTo(-20, 14);
                        lineTo(-20, 29);
                        fill();
                        stroke();

                        beginPath();
                        moveTo(-5, 15);
                        lineTo(-5, 30);
                        lineTo(-1, 27);
                        lineTo(-1, 12);
                        lineTo(-5, 15);
                        fill();
                        stroke();
                        
                        beginPath();
                        moveTo(-5, 15);
                        lineTo(-1, 12);
                        lineTo(-16, 11);
                        lineTo(-20, 14);
                        lineTo(-5, 15);
                        fill();
                        stroke();
                    }

                    ctx.restore();

                    // health bar
                    if(this.health < this.maxHealth){
                        fill(0);
                        ctx.fillRect(-50, -120, 100, 6);
                        
                        fill(200, 0, 0);
                        ctx.fillRect(-50, -120, this.health * 100 / this.maxHealth, 6);
                    }
                }

                // destroyed tower
                else{
                    ctx.save();
                    ctx.translate(-4, 0);
                    ctx.scale(1.25, 1.25);

                    stroke(50, 150, 255);
                    fill(100, 180, 255);

                    with(ctx){

                        // remnants of big cube
                        beginPath();

                        moveTo(-20, -20);
                        lineTo(-10, -30);
                        lineTo(-5, -30);
                        lineTo(5, -35);
                        lineTo(10, -35);
                        lineTo(15, -40);

                        lineTo(20, -30);
                        lineTo(30, -25);
                        lineTo(35, -25);
                        lineTo(40, -30);
                        lineTo(50, -25);

                        lineTo(50, -25);
                        lineTo(40, -20);
                        lineTo(35, -15);
                        lineTo(30, -15);
                        lineTo(25, -10);

                        lineTo(20, 0);
                        lineTo(15, 5);
                        lineTo(5, 0);
                        lineTo(0, -5);
                        lineTo(-5, -5);
                        lineTo(-10, -15);

                        fill();
                        stroke();

                        beginPath();
                        moveTo(20, 20);
                        lineTo(-20, 0);
                        lineTo(-20, -20);

                        lineTo(-10, -15);
                        lineTo(-5, -5);
                        lineTo(0, -5);
                        lineTo(5, 0);
                        lineTo(15, 5);

                        lineTo(20, 0);
                        lineTo(20, 20);
                        fill();
                        stroke();

                        beginPath();
                        moveTo(20, 20);
                        lineTo(55, 0);
                        lineTo(55, -20);

                        lineTo(50, -25);
                        lineTo(40, -20);
                        lineTo(35, -15);
                        lineTo(30, -15);
                        lineTo(25, -10);

                        lineTo(20, 0);
                        lineTo(20, 20);
                        fill();
                        stroke();

                        // remnants of medium cube
                        save();
                        translate(0, 5);
                        beginPath();

                        moveTo(-15, -15);
                        lineTo(-40, 15);
                        lineTo(-15, 10);
                        lineTo(-15, -15);
                        fill();
                        stroke();

                        beginPath();
                        moveTo(-50, 5);
                        lineTo(-40, -5);
                        lineTo(-35, -5);
                        lineTo(-30, -20);

                        lineTo(-25, -25);
                        lineTo(-15, -15);
                        lineTo(-40, 15);
                        lineTo(-50, 5);
                        fill();
                        stroke();

                        restore();

                        // little cube survived!
                        beginPath();
                        moveTo(-20, 28);
                        lineTo(-5, 30);
                        lineTo(-5, 15);
                        lineTo(-20, 14);
                        lineTo(-20, 29);
                        fill();
                        stroke();

                        beginPath();
                        moveTo(-5, 15);
                        lineTo(-5, 30);
                        lineTo(-1, 27);
                        lineTo(-1, 12);
                        lineTo(-5, 15);
                        fill();
                        stroke();
                        
                        beginPath();
                        moveTo(-5, 15);
                        lineTo(-1, 12);
                        lineTo(-16, 11);
                        lineTo(-20, 14);
                        lineTo(-5, 15);
                        fill();
                        stroke();
                    }

                    ctx.restore();
                }

                ctx.restore();
            };
            FreezeTower.prototype.update = function(){

                if(this.health > 0){
                    for(let i = 0; i < entities.length; i++){
                        let en = entities[i];

                        // only freeze enemies and decoys
                        if(en.type !== "enemy" && en.type !== "decoy"){
                            continue;
                        }

                        if(distSQ(en.x, en.y, this.x, this.y) <= Math.pow(this.range, 2)){
                            en.frozen = 120;
                        }
                    }
                }
            
                else{

                    // make the spot buildable again
                    let mapPos = findMapPos(this.x, this.y);

                    if(gameMap[mapPos.i][mapPos.j] === "1"){
                        gameMap[mapPos.i] = gameMap[mapPos.i].slice(0, mapPos.j) + "-" + gameMap[mapPos.i].slice(mapPos.j + 1, gameMap[mapPos.i].length);
                    }

                    // if the player is on the current tile...
                    let playerPos = findMapPos(player.x, player.y);
                    if(mapPos.j === playerPos.j && mapPos.i === playerPos.i){

                        // check if they're trying to build something
                        let building = false;

                        for(let i = 0; i < player.towerButtons.length; i++){
                            let btn = player.towerButtons[i];

                            if(keys[btn.key] && player.gold >= player.costOf(btn.towerType)){
                                building = true;
                                break;
                            }
                        }

                        // if they are, remove this tower
                        if(building){
                            this.on = false;
                        }
                    }
                }

            };


            // a partially built tower
            var InProgressTower = function(x, y, type){

                // entity type
                this.type = "inProgress";

                // whether or not it can move
                this.mobile = false;

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;

                // type of tower
                this.type = type;

                // size
                this.sz = 80;

                // stage of build
                this.stage = 0;

            };
            InProgressTower.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3);

                if(this.type === FreezeTower){
                    ctx.save();
                    ctx.translate(-4, 0);
                    ctx.scale(1.25, 1.25);

                    stroke(50, 150, 255);
                    fill(100, 180, 255);

                    with(ctx){
                        // big cube
                        beginPath();
                        moveTo(20, 20);
                        lineTo(-20, 0);
                        lineTo(-20, -40);
                        lineTo(20, -20);
                        lineTo(20, 20);
                        fill();
                        stroke();

                        beginPath();
                        moveTo(20, 20);
                        lineTo(55, 0);
                        lineTo(55, -40);
                        lineTo(20, -20);
                        lineTo(20, 20);
                        fill();
                        stroke();

                        beginPath();
                        moveTo(20, -20);
                        lineTo(-20, -40);
                        lineTo(15, -60);
                        lineTo(55, -40);
                        lineTo(20, -20);
                        fill();
                        stroke();

                        // medium cube
                        if(this.stage === 1){
                            save();
                            translate(0, 5);
                            beginPath();
                            moveTo(-40, -10);
                            lineTo(-40, 15);
                            lineTo(-15, 10);
                            lineTo(-15, -15);
                            lineTo(-40, -10);
                            fill();
                            stroke();

                            beginPath();
                            moveTo(-40, -10);
                            lineTo(-40, 15);
                            lineTo(-50, 5);
                            lineTo(-50, -20);
                            lineTo(-40, -10);
                            fill();
                            stroke();

                            beginPath();
                            moveTo(-40, -10);
                            lineTo(-50, -20);
                            lineTo(-25, -25);
                            lineTo(-15, -15);
                            lineTo(-40, -10);
                            fill();
                            stroke();

                            restore();
                        }
                    }

                    ctx.restore();
                }

                else{

                    ctx.save();
                    if(this.stage === 1){
                        ctx.scale(-1, 1);
                    }

                    // base
                    fill(120);
                    with(ctx){
                        beginPath();

                        moveTo(-40, 0);
                        ellipse(0, -50 - 40 * this.stage, 40, 40 / rt3, 0, angle(180), angle(220));
                        ellipse(0, -40 - 40 * this.stage, 40, 40 / rt3, 0, angle(220), angle(260));
                        ellipse(0, -50 - 40 * this.stage, 40, 40 / rt3, 0, angle(260), angle(300));
                        ellipse(0, -60 - 40 * this.stage, 40, 40 / rt3, 0, angle(300), angle(360));
                        lineTo(40, 0);

                        fill();
                    }

                    fill(150);
                    with(ctx){
                        beginPath();

                        moveTo(-40, 1);
                        ellipse(0, -50 - 40 * this.stage, 40, 40 / rt3, 0, angle(180), angle(150), true);
                        ellipse(0, -40 - 40 * this.stage, 40, 40 / rt3, 0, angle(150), angle(80), true);
                        ellipse(0, -50 - 40 * this.stage, 40, 40 / rt3, 0, angle(80), angle(30), true);
                        ellipse(0, -60 - 40 * this.stage, 40, 40 / rt3, 0, angle(30), 0, true);
                        lineTo(40, 1);

                        fill();
                    }

                    arc(0, 0, 80, 80 / rt3, 0, 180);

                    ctx.restore();

                    // shadows
                    for(let i = 0; i < 20; i++){
                        let theta = Math.acos((40 - i) / 40), yOff = theta > angle(30) ? 10 : 0;

                        fill(0, 60 - i * 3);
                        ctx.fillRect(i - 40, -50 - 50 * this.stage + yOff + 40 * Math.sin(theta) / rt3, 1, 51 + 50 * this.stage - yOff);
                    }

                    // scaffolding
                    ctx.lineWidth = 3;

                    stroke(140, 70, 0);
                    fill(150, 100, 0);
                    with(ctx){
                        beginPath();

                        moveTo(45, -35);
                        lineTo(45, 0);
                        
                        moveTo(58, -35);
                        lineTo(58, 0);

                        stroke();

                        beginPath();

                        moveTo(45, -30);
                        lineTo(60, -30);
                        lineTo(35, -5);
                        lineTo(20, -5);

                        fill();

                        beginPath();

                        moveTo(20, -10);
                        lineTo(20, 25);
                        
                        moveTo(33, -10);
                        lineTo(33, 25);

                        stroke();

                        if(this.stage === 1){
                            beginPath();

                            moveTo(-45, -75);
                            lineTo(-45, 0);
                            
                            moveTo(-58, -75);
                            lineTo(-58, 0);

                            stroke();

                            beginPath();

                            moveTo(-45, -30);
                            lineTo(-60, -30);
                            lineTo(-35, -5);
                            lineTo(-20, -5);

                            moveTo(-45, -70);
                            lineTo(-60, -70);
                            lineTo(-35, -45);
                            lineTo(-20, -45);

                            fill();

                            beginPath();

                            moveTo(-20, -50);
                            lineTo(-20, 25);
                            
                            moveTo(-33, -50);
                            lineTo(-33, 25);

                            stroke();
                        }
                    }

                    ctx.lineWidth = 1;
                }

                ctx.restore();
            };
            InProgressTower.prototype.update = function(){
                // needs to have an update function so that updateEntites won't throw an error
            };

            // the icon that appears above entities' heads when they're frozen
            var freezeIcon = function(x, y){
                ctx.save();
                ctx.translate(x, y);

                ctx.lineWidth = 3;
                stroke(150, 200, 255);

                with(ctx){
                    beginPath();

                    moveTo(0, -20);
                    lineTo(0, 20);

                    moveTo(-10 * rt3, -10);
                    lineTo(10 * rt3, 10);

                    moveTo(10 * rt3, -10);
                    lineTo(-10 * rt3, 10);

                    moveTo(0, -10);
                    lineTo(5 * rt3, -5);
                    lineTo(5 * rt3, 5);
                    lineTo(0, 10);
                    lineTo(-5 * rt3, 5);
                    lineTo(-5 * rt3, -5);
                    lineTo(0, -10);

                    moveTo(-2.5 * rt3, -17.5);
                    lineTo(0, -15);
                    lineTo(2.5 * rt3, -17.5);

                    moveTo(7.5 * rt3, -12.5);
                    lineTo(7.5 * rt3, -7.5);
                    lineTo(10 * rt3, -5);

                    moveTo(10 * rt3, 5);
                    lineTo(7.5 * rt3, 7.5);
                    lineTo(7.5 * rt3, 12.5);

                    moveTo(2.5 * rt3, 17.5);
                    lineTo(0, 15);
                    lineTo(-2.5 * rt3, 17.5);

                    moveTo(-7.5 * rt3, 12.5);
                    lineTo(-7.5 * rt3, 7.5);
                    lineTo(-10 * rt3, 5);

                    moveTo(-10 * rt3, -5);
                    lineTo(-7.5 * rt3, -7.5);
                    lineTo(-7.5 * rt3, -12.5);

                    stroke();
                }

                ctx.lineWidth = 1;

                ctx.restore();
            };

        </script>

        <!-- enemies -->
        <script>
            var Goblin = function(x, y){

                // entity type
                this.type = "enemy";

                // whether or not it can move
                this.mobile = true;

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;

                // coords from previous frame
                this.px = x;
                this.py = y;

                // velocity
                this.vel = {x: 0, y: 0};

                // which direction it's facing
                this.dir = {x: 0, y: 1};
                this.r = 90;

                // diameter
                this.sz = 25;

                // stats
                this.maxSpeed = 5; // default movement speed
                this.speed = this.maxSpeed; // speed
                this.dmg = 10; // damage
                this.xp = 5; // experience awarded
                this.gold = 5; // sweet, sweet cash
                this.health = 20; // health
                this.maxHealth = 20; // maximum health
                this.range = 90; // attack range
                this.vis = 1000; // visual range

                // whether or not it's slowed
                this.slowed = false;

                // what it's doing
                this.action = "stand";

                // action from previous frame
                this.pAction = "stand";

                // what it's targeting
                this.target = castle;

                // x- and y-translation
                this.tx = 0;
                this.ty = 0;

                // right hand
                this.hand1 = {
                    x: -25,
                    y: -5,
                    r: 70
                };

                // left hand
                this.hand2 = {
                    x: 20,
                    y: -10
                };

                // sword slash
                let t = this;
                this.slash = {
                    r0: false,
                    r: 0,
                    count: 0,
                    draw: function(){
                        ctx.save();
                        ctx.translate(0, t.hand1.y);
                        ctx.scale(1, 1 / rt3);

                        fill(150, 50);
                        with(ctx){
                            beginPath();

                            moveTo(t.range * cos(this.r), t.range * sin(this.r));
                            arc(0, 0, t.range, angle(this.r), angle(this.r0), true);
                            lineTo(0, 0);

                            fill();
                        }

                        ctx.globalAlpha = 1;

                        ctx.restore();
                    }
                };

                // collision variables
                this.left = true;
                this.right = true;
                this.up = true;
                this.down = true;

                // actions
                this.stand = function(){

                    if(this.dir.x === -1){
                        this.hand1.x = -20;
                        this.hand1.y = -15;
                        this.hand1.r = -30;
                        this.hand1.inFront = false;
                        
                        this.hand2.x = 10;
                        this.hand2.y = -10;
                        this.hand2.inFront = true;
                    }

                    else if(this.dir.x === 1){
                        this.hand1.x = 20;
                        this.hand1.y = -5;
                        this.hand1.r = 30;
                        this.hand1.inFront = true;

                        this.hand2.x = -10;
                        this.hand2.y = -10;
                        this.hand2.inFront = false;
                    }

                    else if(this.dir.y === -1){
                        this.hand1.x = 20;
                        this.hand1.y = -10;
                        this.hand1.r = -50;
                        this.hand1.inFront = false;

                        this.hand2.x = -20;
                        this.hand2.y = -15;
                        this.hand2.inFront = false;
                    }

                    else if(this.dir.y === 1){
                        this.hand1.x = -25;
                        this.hand1.y = -5;
                        this.hand1.r = 70;
                        this.hand1.inFront = true;

                        this.hand2.x = 20;
                        this.hand2.y = -10;
                        this.hand2.inFront = true;
                    }

                    this.slash.r0 = false;
                    this.slash.r = 0;
                    this.slash.count = 0;

                };
                this.attack = function(){

                    if(this.slash.r0 === false){
                        this.slash.r0 = (
                            this.dir.x === 1 ? 0 :
                            this.dir.x === -1 ? 180 :
                            this.dir.y === 1 ? 90 :
                            270
                        );
                    }

                    if(this.slash.r - this.slash.r0 > 360){
                        this.dealDamage();
                        this.action = "stand";
                    }

                    else{
                        this.slash.count++;
                    }
                    
                    this.slash.r = (this.slash.r0 + this.slash.count * 30);
                    
                    this.hand1.r = this.slash.r + 90;
                    this.hand1.inFront = (this.slash.r % 360 <= 180);

                    this.hand1.x = 40 * cos(this.slash.r);
                };
                
            };
            Goblin.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3);

                this.slash.draw();

                ctx.scale(0.75, 0.75);

                // shadow
                fill(0, 50);
                ellipse(0, 0, 40, 40 / rt3);

                ctx.translate(this.tx, this.ty);

                // right hand
                if(this.dir.x < 0 || this.dir.x === 0 && this.dir.y === -1){
                    ctx.save();
                    ctx.translate(this.hand1.x, this.hand1.y);
                    ctx.rotate(angle(this.hand1.r));

                    fill(120);
                    with(ctx){
                        beginPath();

                        moveTo(-3, 0);
                        bezierCurveTo(-3, -20, -3, -60, 0, -70);
                        bezierCurveTo(3, -60, 3, -20, 3, 0);

                        fill();
                    }

                    fill(86, 112, 0);
                    ellipse(0, 0, 12, 12);

                    fill(100, 50, 0);
                    ellipse(-5, -6, 4, 4);
                    ellipse(5, -6, 4, 4);
                    ctx.fillRect(-5, -8, 10, 4);

                    ctx.restore();
                }

                // left hand
                if(this.dir.x > 0 || this.dir.x === 0 && this.dir.y === -1){
                    fill(86, 112, 0);
                    ellipse(this.hand2.x, this.hand2.y, 12, 12);
                }

                // body
                fill(86, 112, 0);
                ellipse(0, -20, 40, 40);

                // horns
                if(this.dir.x === 0){
                    with(ctx){
                        beginPath();

                        moveTo(-15, -30);
                        lineTo(-15, -50);
                        lineTo(-5, -30);

                        moveTo(15, -30);
                        lineTo(15, -50);
                        lineTo(5, -30);

                        fill();
                    }
                }

                else{
                    with(ctx){
                        beginPath();

                        moveTo(-5, -30);
                        lineTo(0, -50);
                        lineTo(5, -30);

                        fill();
                    }
                }

                // eyes
                fill(200, 200, 0);

                if(this.dir.x === -1){
                    ellipse(-10, -25, 4, 4);
                }

                else if(this.dir.x === 1){
                    ellipse(10, -25, 4, 4);
                }

                else if(this.dir.y === 1){
                    ellipse(-6, -25, 4, 4);
                    ellipse(6, -25, 4, 4);
                }

                // clothes
                fill(100, 50, 0);
                with(ctx){
                    beginPath();

                    moveTo(0, -20);
                    arc(0, -20, 20, angle(180), 0, true);
                    bezierCurveTo(8, -12, -8, -12, -20, -20);

                    fill();
                }

                // right hand
                if(this.dir.x > 0 || this.dir.x === 0 && this.dir.y === 1){
                    ctx.save();
                    ctx.translate(this.hand1.x, this.hand1.y);
                    ctx.rotate(angle(this.hand1.r));

                    fill(150, 120, 120);
                    with(ctx){
                        beginPath();

                        moveTo(-3, 0);
                        bezierCurveTo(-3, -20, -3, -60, 0, -70);
                        bezierCurveTo(3, -60, 3, -20, 3, 0);

                        fill();
                    }

                    fill(86, 112, 0);
                    ellipse(0, 0, 12, 12);

                    fill(80, 20, 20);
                    ellipse(-5, -6, 4, 4);
                    ellipse(5, -6, 4, 4);
                    ctx.fillRect(-5, -8, 10, 4);

                    ctx.restore();
                }

                // left hand
                if(this.dir.x === -1 || this.dir.x === 0 && this.dir.y === 1){
                    fill(86, 112, 0);
                    ellipse(this.hand2.x, this.hand2.y, 12, 12);
                }

                // health bar
                fill(0);
                ctx.fillRect(-25, -70, 50, 3);

                fill(200, 0, 0);
                if(this.health > 0){
                    ctx.fillRect(-25, -70, this.health * 50 / this.maxHealth, 3);
                }

                // freeze icon
                if(this.frozen){
                    freezeIcon(0, -this.sz * 4);
                }

                ctx.restore();
            };
            Goblin.prototype.update = function(){

                // if it's dead, add loot and remove
                if(this.health <= 0){
                    addMoney(this.gold, this.x, this.y, -this.sz / 2);
                    addEntity(new XP(this.x, this.y, -this.sz, this.xp));
                    player.xp += this.xp;

                    this.on = false;
                    return;
                }
                
                // if it's frozen, move more slowly and take damage
                if(this.frozen > 0){
                    this.speed = this.maxSpeed / 2;
                    this.health -= 0.1;
                    this.frozen--;
                }

                else{
                    this.speed = this.maxSpeed;
                }

                // pick a target
                this.target = this.findTarget();

                // if there's no target, something's gone wrong
                if(!this.target){
                    console.log("No targets found.");
                }
                
                // otherwise, if we're within range of the target and the attacking animation is finished, stop and attack
                else if(distSQ(this.x, this.y, this.target.x, this.target.y) < Math.pow(this.range, 2)){
                    if(this.action !== "attack" && this.pAction !== "attack"){
                        this.vel.x = 0;
                        this.vel.y = 0;
                        
                        this.action = "attack";
                    }
                }

                // otherwise, move towards it
                else if(this.action === "stand"){

                    // stop attacking
                    this.action = "stand";

                    // the angle to the target
                    this.r = atan2(this.target.y - this.y, this.target.x - this.x);

                    // the current angle it's facing
                    let r = atan2(this.dir.y, this.dir.x);

                    // if the angle it's facing is too far away from the angle to the target, turn to face closer
                    if(Math.abs(this.r - r) > 45 && Math.abs((this.r + 180) % 360 - (r + 180) % 360) > 45){
                        
                        // we're constrained to multiples of 45 degrees for which way to face
                        this.dir.x = this.r < 67.5 || this.r > 292.5 ? 1 : this.r > 112.5 && this.r < 247.5 ? -1 : 0;
                        this.dir.y = this.r > 22.5 && this.r < 157.5 ? 1 : this.r > 202.5 && this.r < 337.5 ? -1 : 0;
                    }

                    // set velocity according to direction
                    this.vel.x = this.dir.y === 0 ? this.dir.x * this.speed : this.dir.x * this.speed / rt2;
                    this.vel.y = this.dir.x === 0 ? this.dir.y * this.speed : this.dir.y * this.speed / rt2;

                }
                
                // check for collisions
                this.vel.x = constrain(this.vel.x, this.left ? -Infinity : 0, this.right ? Infinity : 0);
                this.vel.y = constrain(this.vel.y, this.up ? -Infinity : 0, this.down ? Infinity : 0);

                // update previous coordinates
                this.px = this.x;
                this.py = this.y;

                // update coordinates
                this.x += this.vel.x;
                this.y += this.vel.y;

                // update previous action
                this.pAction = this.action;

                // execute action
                this[this.action]();

            };
            Goblin.prototype.findTarget = function(){

                // loop through all entities
                let closest = castle, dist = distSQ(this.x, this.y, castle.x, castle.y);
                for(let i = 0; i < entities.length; i++){
                    let en = entities[i];

                    // only check the player and decoys
                    if(en.type !== "player" && en.type !== "decoy"){
                        continue;
                    }

                    // the distance to the current entity
                    let curDist = distSQ(this.x, this.y, en.x, en.y);

                    // if this entity is still alive, is within visual range, and is closer than the current closest...
                    if(en.health > 0 && curDist <= Math.pow(this.vis, 2) && curDist < dist){
                        dist = curDist;
                        closest = en;
                    }
                }

                // return the closest entity found, or the castle if none were within visual range
                return closest;

            };
            Goblin.prototype.dealDamage = function(){

                // loop through all entities
                for(let i = 0; i < entities.length; i++){
                    let en = entities[i];

                    // only damage the player, castle, and decoys
                    if(en.type !== "player" && en.type !== "castle" && en.type !== "decoy"){
                        continue;
                    }

                    // deal damage to the enemy if it's within range
                    if(distSQ(this.x, this.y, en.x, en.y) <= Math.pow(this.range, 2)){
                        en.health -= this.dmg;
                    }
                }
            };

            var Archer = function(x, y){

                // entity type
                this.type = "enemy";

                // whether or not it can move
                this.mobile = true;

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;

                // coords from previous frame
                this.px = x;
                this.py = y;

                // velocity
                this.vel = {x: 0, y: 0};

                // which direction it's facing
                this.dir = {x: 0, y: 1};
                this.r = 90;

                // diameter
                this.sz = 25;

                // stats
                this.maxSpeed = 7; // default movement speed
                this.speed = this.maxSpeed; // speed
                this.xp = 7; // experience awarded
                this.gold = 7; // sweet, sweet cash
                this.health = 20; // health
                this.maxHealth = 20; // maximum health
                this.range = 500; // attack range
                this.vis = 1500; // visual range
                this.maxCool = 20; // attack cooldown
                this.cool = 0; // how long until it can attack

                // whether or not it's slowed
                this.slowed = false;

                // what it's doing
                this.action = "stand";

                // action from previous frame
                this.pAction = "stand";

                // what it's targeting
                this.target = castle;

                // x- and y-translation
                this.tx = 0;
                this.ty = 0;

                // right hand
                this.hand1 = {
                    x: -25,
                    y: -5,
                    r: 70
                };

                // left hand
                this.hand2 = {
                    x: 20,
                    y: -10
                };

                // collision variables
                this.left = true;
                this.right = true;
                this.up = true;
                this.down = true;

                // actions
                this.stand = function(){

                    if(this.dir.x === -1){
                        this.hand1.x = -15;
                        this.hand1.y = -10;
                        this.hand1.r = 0;
                        this.hand1.inFront = false;
                        
                        this.hand2.x = -30;
                        this.hand2.y = -10;
                        this.hand2.inFront = true;
                    }

                    else if(this.dir.x === 1){
                        this.hand1.x = 15;
                        this.hand1.y = -10;
                        this.hand1.r = 0;
                        this.hand1.inFront = true;

                        this.hand2.x = 35;
                        this.hand2.y = -15;
                        this.hand2.inFront = false;
                    }

                    else if(this.dir.y === -1){
                        this.hand1.x = 5;
                        this.hand1.y = -10;
                        this.hand1.r = 0;
                        this.hand1.inFront = false;

                        this.hand2.x = -5;
                        this.hand2.y = -45;
                        this.hand2.inFront = false;
                    }

                    else if(this.dir.y === 1){
                        this.hand1.x = -5;
                        this.hand1.y = -10;
                        this.hand1.r = 0;
                        this.hand1.inFront = true;

                        this.hand2.x = 5;
                        this.hand2.y = -3;
                        this.hand2.inFront = true;
                    }

                };
                
            };
            Archer.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3);

                ctx.scale(0.75, 0.75);

                // shadow
                fill(0, 50);
                ellipse(0, 0, 40, 40 / rt3);

                ctx.translate(this.tx, this.ty);

                // right hand
                if(this.dir.x < 0 || this.dir.x === 0 && this.dir.y === -1){
                    ctx.save();
                    ctx.translate(this.hand1.x, this.hand1.y);
                    ctx.rotate(angle(this.hand1.r));

                    fill(86, 112, 0);
                    ellipse(0, 0, 12, 12);

                    ctx.restore();
                }

                // left hand
                if(this.dir.x > 0 || this.dir.x === 0 && this.dir.y === -1){
                    fill(86, 112, 0);
                    ellipse(this.hand2.x, this.hand2.y, 12, 12);
                }

                // crossbow (up)
                if(this.dir.x === 0 && this.dir.y === -1){
                    ctx.save();
                    ctx.translate(0, -50);

                    fill(140, 70, 0);
                    with(ctx){
                        beginPath();
                        moveTo(-3, 18);
                        lineTo(-5, 5);

                        bezierCurveTo(-10, 5, -15, 5, -30, 10);
                        bezierCurveTo(-15, -8, 15, -8, 30, 10);
                        bezierCurveTo(15, 5, 10, 5, 5, 5);

                        lineTo(3, 18);
                        fill();
                    }

                    stroke(50);
                    with(ctx){
                        beginPath();
                        moveTo(-30, 10);
                        lineTo(0, 18);
                        lineTo(30, 10);
                        stroke();
                    }

                    fill(0);
                    stroke(0);
                    with(ctx){
                        beginPath();
                        moveTo(0, 18);
                        lineTo(0, -3);
                        lineTo(-2, -3);
                        lineTo(0, -6);
                        lineTo(2, -3);
                        lineTo(0, -3);
                        fill();
                        stroke();
                    }

                    ctx.restore();
                }

                // crossbow (left)
                if(this.dir.x < 0){
                    fill(140, 70, 0);
                    with(ctx){
                        beginPath();
                        moveTo(-25, -20);
                        lineTo(-50, -20);
                        lineTo(-50, -10);
                        lineTo(-25, -15);
                        lineTo(-10, -8);
                        lineTo(-10, -18);
                        fill();

                        beginPath();
                        moveTo(-45, -20);
                        bezierCurveTo(-45, -15, -35, -5, -25, 0);
                        bezierCurveTo(-40, 0, -45, -5, -50, -10);
                        lineTo(-50, -20);
                        bezierCurveTo(-45, -25, -40, -30, -25, -30);
                        bezierCurveTo(-35, -25, -45, -15, -45, -10);
                        fill();
                    }

                    stroke(50);
                    with(ctx){
                        beginPath();
                        moveTo(-25, 0);
                        lineTo(-20, -18);
                        lineTo(-25, -30);
                        stroke();
                    }

                    stroke(0);
                    fill(0);
                    with(ctx){
                        beginPath();
                        moveTo(-20, -18);
                        lineTo(-50, -18);
                        lineTo(-50, -20);
                        lineTo(-55, -18);
                        lineTo(-50, -16);
                        lineTo(-50, -18);
                        fill();
                        stroke();
                    }
                }

                // body
                fill(86, 112, 0);
                ellipse(0, -20, 40, 40);

                // horns
                if(this.dir.x === 0){
                    with(ctx){
                        beginPath();

                        moveTo(-15, -30);
                        lineTo(-15, -50);
                        lineTo(-5, -30);

                        moveTo(15, -30);
                        lineTo(15, -50);
                        lineTo(5, -30);

                        fill();
                    }
                }

                else{
                    with(ctx){
                        beginPath();

                        moveTo(-5, -30);
                        lineTo(0, -50);
                        lineTo(5, -30);

                        fill();
                    }
                }

                // eyes
                fill(200, 200, 0);

                if(this.dir.x === -1){
                    ellipse(-10, -25, 4, 4);
                }

                else if(this.dir.x === 1){
                    ellipse(10, -25, 4, 4);
                }

                else if(this.dir.y === 1){
                    ellipse(-6, -25, 4, 4);
                    ellipse(6, -25, 4, 4);
                }

                // clothes
                fill(100, 50, 0);
                fill(50);
                with(ctx){
                    beginPath();

                    moveTo(0, -20);
                    arc(0, -20, 20, angle(180), 0, true);
                    bezierCurveTo(8, -12, -8, -12, -20, -20);

                    fill();
                }

                // crossbow (right)
                if(this.dir.x > 0){
                    fill(140, 70, 0);
                    with(ctx){
                        beginPath();
                        moveTo(25, -20);
                        lineTo(50, -20);
                        lineTo(50, -10);
                        lineTo(25, -15);
                        lineTo(10, -8);
                        lineTo(10, -18);
                        fill();

                        beginPath();
                        moveTo(45, -20);
                        bezierCurveTo(45, -15, 35, -5, 25, 0);
                        bezierCurveTo(40, 0, 45, -5, 50, -10);
                        lineTo(50, -20);
                        bezierCurveTo(45, -25, 40, -30, 25, -30);
                        bezierCurveTo(35, -25, 45, -15, 45, -10);
                        fill();
                    }

                    stroke(50);
                    with(ctx){
                        beginPath();
                        moveTo(25, 0);
                        lineTo(20, -18);
                        lineTo(25, -30);
                        stroke();
                    }

                    stroke(0);
                    fill(0);
                    with(ctx){
                        beginPath();
                        moveTo(20, -18);
                        lineTo(50, -18);
                        lineTo(50, -20);
                        lineTo(55, -18);
                        lineTo(50, -16);
                        lineTo(50, -18);
                        fill();
                        stroke();
                    }
                }

                // right hand
                if(this.dir.x > 0 || this.dir.x === 0 && this.dir.y === 1){
                    ctx.save();
                    ctx.translate(this.hand1.x, this.hand1.y);
                    ctx.rotate(angle(this.hand1.r));

                    fill(86, 112, 0);
                    ellipse(0, 0, 12, 12);

                    ctx.restore();
                }

                // left hand
                if(this.dir.x === -1 || this.dir.x === 0 && this.dir.y === 1){
                    fill(86, 112, 0);
                    ellipse(this.hand2.x, this.hand2.y, 12, 12);
                }

                // crossbow (down)
                if(this.dir.x === 0 && this.dir.y === 1){
                    fill(140, 70, 0);
                    with(ctx){
                        beginPath();
                        moveTo(-3, -18);
                        lineTo(-5, -5);

                        bezierCurveTo(-10, -5, -15, -5, -30, -10);
                        bezierCurveTo(-15, 8, 15, 8, 30, -10);
                        bezierCurveTo(15, -5, 10, -5, 5, -5);

                        lineTo(3, -18);
                        fill();
                    }

                    stroke(50);
                    with(ctx){
                        beginPath();
                        moveTo(-30, -10);
                        lineTo(0, -18);
                        lineTo(30, -10);
                        stroke();
                    }

                    fill(0);
                    stroke(0);
                    with(ctx){
                        beginPath();
                        moveTo(0, -18);
                        lineTo(0, -5);
                        lineTo(-2, -5);
                        lineTo(0, -2);
                        lineTo(2, -5);
                        lineTo(0, -5);
                        fill();
                        stroke();
                    }
                }

                // health bar
                fill(0);
                ctx.fillRect(-25, -70, 50, 3);

                fill(200, 0, 0);
                if(this.health > 0){
                    ctx.fillRect(-25, -70, this.health * 50 / this.maxHealth, 3);
                }

                // freeze icon
                if(this.frozen){
                    freezeIcon(0, -this.sz * 4);
                }

                ctx.restore();
            };
            Archer.prototype.update = function(){

                // if it's dead, add loot and remove
                if(this.health <= 0){
                    addMoney(this.gold, this.x, this.y, -this.sz / 2);
                    addEntity(new XP(this.x, this.y, -this.sz, this.xp));
                    player.xp += this.xp;

                    this.on = false;
                    return;
                }
                
                // if it's frozen, move more slowly and take damage
                if(this.frozen > 0){
                    this.speed = this.maxSpeed / 2;
                    this.health -= 0.1;
                    this.frozen--;
                }

                else{
                    this.speed = this.maxSpeed;
                }

                // pick a target
                this.target = this.findTarget();

                // if there's no target, something's gone wrong
                if(!this.target){
                    console.log("No targets found.");
                }
                
                // otherwise, if we're within range of the target and the attacking animation is finished, stop and attack
                else if(distSQ(this.x, this.y, this.target.x, this.target.y) < Math.pow(this.range, 2)){
                    
                    // stop moving
                    this.vel.x = 0;
                    this.vel.y = 0;

                    // the angle to the target
                    this.r = atan2(this.target.y - this.y, this.target.x - this.x);

                    // we're constrained to multiples of 45 degrees for which way to face
                    this.dir.x = this.r < 67.5 || this.r > 292.5 ? 1 : this.r > 112.5 && this.r < 247.5 ? -1 : 0;
                    this.dir.y = this.r > 22.5 && this.r < 157.5 ? 1 : this.r > 202.5 && this.r < 337.5 ? -1 : 0;

                    // fire!
                    if(this.cool === 0){
                        addEntity(new GoblinArrow(this.x, this.y, -this.sz / 2, this.target));
                        this.cool = this.maxCool;
                    }
                }

                // otherwise, move towards it
                else if(this.action === "stand"){

                    // stop attacking
                    this.action = "stand";

                    // the angle to the target
                    this.r = atan2(this.target.y - this.y, this.target.x - this.x);

                    // the current angle it's facing
                    let r = atan2(this.dir.y, this.dir.x);

                    // if the angle it's facing is too far away from the angle to the target, turn to face closer
                    if(Math.abs(this.r - r) > 45 && Math.abs((this.r + 180) % 360 - (r + 180) % 360) > 45){

                        // we're constrained to multiples of 45 degrees for which way to face
                        this.dir.x = this.r < 67.5 || this.r > 292.5 ? 1 : this.r > 112.5 && this.r < 247.5 ? -1 : 0;
                        this.dir.y = this.r > 22.5 && this.r < 157.5 ? 1 : this.r > 202.5 && this.r < 337.5 ? -1 : 0;
                    }

                    // set velocity according to direction
                    this.vel.x = this.dir.y === 0 ? this.dir.x * this.speed : this.dir.x * this.speed / rt2;
                    this.vel.y = this.dir.x === 0 ? this.dir.y * this.speed : this.dir.y * this.speed / rt2;

                }

                // update previous coordinates
                this.px = this.x;
                this.py = this.y;

                // update coordinates
                this.x += this.vel.x;
                this.y += this.vel.y;

                // update previous action
                this.pAction = this.action;

                // execute action
                this[this.action]();

                // update attack cooldown
                if(this.cool > 0){
                    this.cool--;
                }

            };
            Archer.prototype.findTarget = function(){

                // loop through all entities
                let closest = castle, dist = distSQ(this.x, this.y, castle.x, castle.y);
                for(let i = 0; i < entities.length; i++){
                    let en = entities[i];

                    // only check the player and decoys
                    if(en.type !== "player" && en.type !== "decoy"){
                        continue;
                    }

                    // the distance to the current entity
                    let curDist = distSQ(this.x, this.y, en.x, en.y);

                    // if this entity is still alive, is within visual range, and is closer than the current closest...
                    if(en.health > 0 && curDist <= Math.pow(this.vis, 2) && curDist < dist){
                        dist = curDist;
                        closest = en;
                    }
                }

                // return the closest entity found, or the castle if none were within visual range
                return closest;

            };

            var Troll = function(x, y){

                // entity type
                this.type = "enemy";

                // whether or not it can move
                this.mobile = true;

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;

                // coords from previous frame
                this.px = x;
                this.py = y;

                // velocity
                this.vel = {x: 0, y: 0};

                // which direction it's facing
                this.dir = {x: 0, y: 1};
                this.r = 90;

                // diameter
                this.sz = 30;

                // stats
                this.maxSpeed = 3; // default movement speed
                this.speed = this.maxSpeed; // speed
                this.dmg = 15; // damage
                this.xp = 20; // experience awarded
                this.gold = 10; // sweet, sweet cash
                this.health = 200; // health
                this.maxHealth = 200; // maximum health
                this.range = 150; // attack range
                this.vis = 1000; // visual range

                // whether or not it's slowed
                this.slowed = false;

                // what it's doing
                this.action = "stand";

                // action from previous frame
                this.pAction = "stand";

                // what it's targeting
                this.target = castle;

                // x- and y-translation
                this.tx = 0;
                this.ty = 0;

                // right hand
                this.hand1 = {
                    x: -25,
                    y: -5,
                    r: 70
                };

                // left hand
                this.hand2 = {
                    x: 20,
                    y: -10
                };

                // sword slash
                let t = this;
                this.slash = {
                    r0: false,
                    r: 0,
                    count: 0,
                    draw: function(){
                        ctx.save();
                        ctx.translate(0, t.hand1.y);
                        ctx.scale(1, 1 / rt3);

                        fill(100, 50, 0, 50);
                        with(ctx){
                            beginPath();

                            moveTo(t.range * cos(this.r), t.range * sin(this.r));
                            arc(0, 0, t.range, angle(this.r), angle(this.r0), true);
                            lineTo(0, 0);

                            fill();
                        }

                        ctx.globalAlpha = 1;

                        ctx.restore();
                    }
                };

                // collision variables
                this.left = true;
                this.right = true;
                this.up = true;
                this.down = true;

                // actions
                this.stand = function(){

                    if(this.dir.x === -1){
                        this.hand1.x = -20;
                        this.hand1.y = -15;
                        this.hand1.r = -30;
                        this.hand1.inFront = false;
                        
                        this.hand2.x = 10;
                        this.hand2.y = -10;
                        this.hand2.inFront = true;
                    }

                    else if(this.dir.x === 1){
                        this.hand1.x = 20;
                        this.hand1.y = -5;
                        this.hand1.r = 30;
                        this.hand1.inFront = true;

                        this.hand2.x = -10;
                        this.hand2.y = -10;
                        this.hand2.inFront = false;
                    }

                    else if(this.dir.y === -1){
                        this.hand1.x = 20;
                        this.hand1.y = -10;
                        this.hand1.r = -50;
                        this.hand1.inFront = false;

                        this.hand2.x = -20;
                        this.hand2.y = -15;
                        this.hand2.inFront = false;
                    }

                    else if(this.dir.y === 1){
                        this.hand1.x = -25;
                        this.hand1.y = -5;
                        this.hand1.r = 70;
                        this.hand1.inFront = true;

                        this.hand2.x = 20;
                        this.hand2.y = -10;
                        this.hand2.inFront = true;
                    }

                    this.slash.r0 = false;
                    this.slash.r = 0;
                    this.slash.count = 0;

                };
                this.attack = function(){

                    if(this.slash.r0 === false){
                        this.slash.r0 = (
                            this.dir.x === 1 ? 0 :
                            this.dir.x === -1 ? 180 :
                            this.dir.y === 1 ? 90 :
                            270
                        );
                    }

                    if(this.slash.r - this.slash.r0 > 360){
                        this.dealDamage();
                        this.action = "stand";
                    }

                    else{
                        this.slash.count++;
                    }
                    
                    this.slash.r = (this.slash.r0 + this.slash.count * 30);
                    
                    this.hand1.r = this.slash.r + 90;
                    this.hand1.inFront = (this.slash.r % 360 <= 180);

                    this.hand1.x = 40 * cos(this.slash.r);
                };
                
            };
            Troll.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3);

                this.slash.draw();

                ctx.scale(1.25, 1.25);

                // shadow
                fill(0, 50);
                ellipse(0, 0, 40, 40 / rt3);

                ctx.translate(this.tx, this.ty);

                // right hand
                if(this.dir.x < 0 || this.dir.x === 0 && this.dir.y === -1){
                    ctx.save();
                    ctx.translate(this.hand1.x, this.hand1.y);
                    ctx.rotate(angle(this.hand1.r));

                    fill(150, 75, 0);
                    with(ctx){
                        beginPath();

                        moveTo(-3, 0);
                        bezierCurveTo(-3, -20, -10, -65, 0, -70);
                        bezierCurveTo(10, -65, 3, -20, 3, 0);

                        fill();
                    }

                    fill(100);
                    ellipse(0, 0, 12, 12);

                    ctx.restore();
                }

                // left hand
                if(this.dir.x > 0 || this.dir.x === 0 && this.dir.y === -1){
                    fill(100);
                    ellipse(this.hand2.x, this.hand2.y, 12, 12);
                }

                // body
                fill(100);
                ellipse(0, -20, 40, 40);

                // eyes
                fill(0);

                if(this.dir.x === -1){
                    ellipse(-10, -25, 4, 4);
                }

                else if(this.dir.x === 1){
                    ellipse(10, -25, 4, 4);
                }

                else if(this.dir.y === 1){
                    ellipse(-6, -25, 4, 4);
                    ellipse(6, -25, 4, 4);
                }

                // clothes
                fill(100, 50, 0);
                with(ctx){
                    beginPath();

                    moveTo(0, -20);
                    arc(0, -20, 20, angle(180), 0, true);
                    bezierCurveTo(8, -12, -8, -12, -20, -20);

                    fill();
                }

                // right hand
                if(this.dir.x > 0 || this.dir.x === 0 && this.dir.y === 1){
                    ctx.save();
                    ctx.translate(this.hand1.x, this.hand1.y);
                    ctx.rotate(angle(this.hand1.r));

                    fill(150, 75, 0);
                    with(ctx){
                        beginPath();

                        moveTo(-3, 0);
                        bezierCurveTo(-3, -20, -10, -65, 0, -70);
                        bezierCurveTo(10, -65, 3, -20, 3, 0);

                        fill();
                    }

                    fill(100);
                    ellipse(0, 0, 12, 12);

                    ctx.restore();
                }

                // left hand
                if(this.dir.x === -1 || this.dir.x === 0 && this.dir.y === 1){
                    fill(100);
                    ellipse(this.hand2.x, this.hand2.y, 12, 12);
                }

                // health bar
                fill(0);
                ctx.fillRect(-25, -70, 50, 3);

                fill(200, 0, 0);
                if(this.health > 0){
                    ctx.fillRect(-25, -70, this.health * 50 / this.maxHealth, 3);
                }

                // freeze icon
                if(this.frozen){
                    freezeIcon(0, -this.sz * 3.5);
                }

                ctx.restore();
            };
            Troll.prototype.update = function(){

                // if it's dead, add loot and remove
                if(this.health <= 0){
                    addMoney(this.gold, this.x, this.y, -this.sz / 2);
                    addEntity(new XP(this.x, this.y, -this.sz, this.xp));
                    player.xp += this.xp;

                    this.on = false;
                    return;
                }
                
                // if it's frozen, move more slowly and take damage
                if(this.frozen > 0){
                    this.speed = this.maxSpeed / 2;
                    this.health -= 0.1;
                    this.frozen--;
                }

                else{
                    this.speed = this.maxSpeed;
                }

                // pick a target
                this.target = this.findTarget();

                // if there's no target, something's gone wrong
                if(!this.target){
                    console.log("No targets found.");
                }
                
                // otherwise, if we're within range of the target and the attacking animation is finished, stop and attack
                else if(distSQ(this.x, this.y, this.target.x, this.target.y) < Math.pow(this.range, 2)){
                    if(this.action !== "attack" && this.pAction !== "attack"){
                        this.vel.x = 0;
                        this.vel.y = 0;
                        
                        this.action = "attack";
                    }
                }

                // otherwise, move towards it
                else if(this.action === "stand"){

                    // stop attacking
                    this.action = "stand";

                    // the angle to the target
                    this.r = atan2(this.target.y - this.y, this.target.x - this.x);

                    // the current angle it's facing
                    let r = atan2(this.dir.y, this.dir.x);

                    // if the angle it's facing is too far away from the angle to the target, turn to face closer
                    if(Math.abs(this.r - r) > 45 && Math.abs((this.r + 180) % 360 - (r + 180) % 360) > 45){

                        // we're constrained to multiples of 45 degrees for which way to face
                        this.dir.x = this.r < 67.5 || this.r > 292.5 ? 1 : this.r > 112.5 && this.r < 247.5 ? -1 : 0;
                        this.dir.y = this.r > 22.5 && this.r < 157.5 ? 1 : this.r > 202.5 && this.r < 337.5 ? -1 : 0;
                    }

                    // set velocity according to direction
                    this.vel.x = this.dir.y === 0 ? this.dir.x * this.speed : this.dir.x * this.speed / rt2;
                    this.vel.y = this.dir.x === 0 ? this.dir.y * this.speed : this.dir.y * this.speed / rt2;

                }
                
                // check for collisions
                this.vel.x = constrain(this.vel.x, this.left ? -Infinity : 0, this.right ? Infinity : 0);
                this.vel.y = constrain(this.vel.y, this.up ? -Infinity : 0, this.down ? Infinity : 0);

                // update previous coordinates
                this.px = this.x;
                this.py = this.y;

                // update coordinates
                this.x += this.vel.x;
                this.y += this.vel.y;

                // update previous action
                this.pAction = this.action;

                // execute action
                this[this.action]();

            };
            Troll.prototype.findTarget = function(){

                // loop through all entities
                let closest = castle, dist = distSQ(this.x, this.y, castle.x, castle.y);
                for(let i = 0; i < entities.length; i++){
                    let en = entities[i];

                    // only check the player and decoys
                    if(en.type !== "player" && en.type !== "decoy"){
                        continue;
                    }

                    // the distance to the current entity
                    let curDist = distSQ(this.x, this.y, en.x, en.y);

                    // if this entity is still alive, is within visual range, and is closer than the current closest...
                    if(en.health > 0 && curDist <= Math.pow(this.vis, 2) && curDist < dist){
                        dist = curDist;
                        closest = en;
                    }
                }

                // return the closest entity found, or the castle if none were within visual range
                return closest;

            };
            Troll.prototype.dealDamage = function(){

                // loop through all entities
                for(let i = 0; i < entities.length; i++){
                    let en = entities[i];

                    // only damage the player, castle, and decoys
                    if(en.type !== "player" && en.type !== "castle" && en.type !== "decoy"){
                        continue;
                    }

                    // deal damage to the enemy if it's within range
                    if(distSQ(this.x, this.y, en.x, en.y) <= Math.pow(this.range, 2)){
                        en.health -= this.dmg;
                    }
                }
            };
            
            var Bomber = function(x, y){

                // entity type
                this.type = "enemy";

                // whether or not it can move
                this.mobile = true;

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;

                // coords from previous frame
                this.px = x;
                this.py = y;

                // velocity
                this.vel = {x: 0, y: 0};

                // which direction it's facing
                this.dir = {x: 0, y: 1};
                this.r = 90;

                // diameter
                this.sz = 25;

                // stats
                this.maxSpeed = 6; // default movement speed
                this.speed = this.maxSpeed; // speed
                this.xp = 20; // experience awarded
                this.gold = 10; // sweet, sweet cash
                this.health = 100; // health
                this.maxHealth = 100; // maximum health
                this.range = 500; // attack range
                this.vis = 1500; // visual range
                this.maxCool = 60; // attack cooldown
                this.cool = 0; // how long until it can attack

                // whether or not it's slowed
                this.slowed = false;

                // what it's doing
                this.action = "stand";

                // action from previous frame
                this.pAction = "stand";

                // what it's targeting
                this.target = castle;

                // x- and y-translation
                this.tx = 0;
                this.ty = 0;

                // right hand
                this.hand1 = {
                    x: -25,
                    y: -5,
                    r: 70
                };

                // left hand
                this.hand2 = {
                    x: 20,
                    y: -10
                };

                // collision variables
                this.left = true;
                this.right = true;
                this.up = true;
                this.down = true;

                // actions
                this.stand = function(){

                    if(this.dir.x === -1){
                        this.hand1.x = -15;
                        this.hand1.y = -15;
                        this.hand1.r = -30;
                        this.hand1.inFront = false;
                        
                        this.hand2.x = 10;
                        this.hand2.y = -10;
                        this.hand2.inFront = true;
                    }

                    else if(this.dir.x === 1){
                        this.hand1.x = 15;
                        this.hand1.y = -5;
                        this.hand1.r = 30;
                        this.hand1.inFront = true;

                        this.hand2.x = -10;
                        this.hand2.y = -10;
                        this.hand2.inFront = false;
                    }

                    else if(this.dir.y === -1){
                        this.hand1.x = 20;
                        this.hand1.y = -10;
                        this.hand1.r = -20;
                        this.hand1.inFront = false;

                        this.hand2.x = -20;
                        this.hand2.y = -15;
                        this.hand2.inFront = false;
                    }

                    else if(this.dir.y === 1){
                        this.hand1.x = -20;
                        this.hand1.y = -5;
                        this.hand1.r = 20;
                        this.hand1.inFront = true;

                        this.hand2.x = 20;
                        this.hand2.y = -10;
                        this.hand2.inFront = true;
                    }

                };
                
            };
            Bomber.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3);

                // shadow
                fill(0, 50);
                ellipse(0, 0, 40, 40 / rt3);

                ctx.translate(this.tx, this.ty);

                // right hand
                if(this.dir.x < 0 || this.dir.x === 0 && this.dir.y === -1){
                    ctx.save();
                    ctx.translate(this.hand1.x, this.hand1.y);
                    ctx.rotate(angle(this.hand1.r));

                    fill(180, 50, 0);
                    ellipse(0, 0, 12, 12);

                    fill(50);
                    ellipse(0, -10, 20, 20);
                    ctx.fillRect(-5, -22, 10, 5);

                    stroke(0);
                    with(ctx){
                        beginPath();

                        moveTo(0, -22);
                        bezierCurveTo(-2, -25, 8, -27, 0, -30);

                        stroke();
                    }

                    ctx.restore();
                }

                // left hand
                if(this.dir.x > 0 || this.dir.x === 0 && this.dir.y === -1){
                    fill(180, 50, 0);
                    ellipse(this.hand2.x, this.hand2.y, 12, 12);
                }

                // body
                fill(180, 50, 0);
                ellipse(0, -20, 40, 40);

                // horns
                if(this.dir.x === 0){
                    with(ctx){
                        beginPath();

                        moveTo(-15, -30);
                        lineTo(-15, -50);
                        lineTo(-5, -30);

                        moveTo(15, -30);
                        lineTo(15, -50);
                        lineTo(5, -30);

                        fill();
                    }

                    // cap
                    fill(100, 50, 0);
                    with(ctx){
                        beginPath();

                        moveTo(-15, -35);
                        bezierCurveTo(-10, -45, 10, -45, 15, -35);
                        bezierCurveTo(10, -30, -10, -30, -15, -35);

                        fill();
                    }
                }

                else{

                    // cap
                    fill(100, 50, 0);
                    with(ctx){
                        beginPath();

                        moveTo(-15, -35);
                        bezierCurveTo(-10, -45, 10, -45, 15, -35);
                        bezierCurveTo(10, -30, -10, -30, -15, -35);

                        fill();
                    }

                    fill(180, 50, 0);
                    with(ctx){
                        beginPath();

                        moveTo(-5, -30);
                        lineTo(0, -50);
                        lineTo(5, -30);

                        fill();
                    }
                }

                // eyes
                fill(200, 200, 0);

                if(this.dir.x === -1){
                    ellipse(-10, -25, 4, 4);
                }

                else if(this.dir.x === 1){
                    ellipse(10, -25, 4, 4);
                }

                else if(this.dir.y === 1){
                    ellipse(-6, -25, 4, 4);
                    ellipse(6, -25, 4, 4);
                }

                // clothes
                fill(100, 50, 0);
                with(ctx){
                    beginPath();

                    moveTo(0, -20);
                    arc(0, -20, 20, angle(180), 0, true);
                    bezierCurveTo(8, -12, -8, -12, -20, -20);

                    fill();
                }

                // right hand
                if(this.dir.x > 0 || this.dir.x === 0 && this.dir.y === 1){
                    ctx.save();
                    ctx.translate(this.hand1.x, this.hand1.y);
                    ctx.rotate(angle(this.hand1.r));

                    fill(180, 50, 0);
                    ellipse(0, 0, 12, 12);

                    fill(50);
                    ellipse(0, -10, 20, 20);
                    ctx.fillRect(-5, -22, 10, 5);

                    stroke(0);
                    with(ctx){
                        beginPath();

                        moveTo(0, -22);
                        bezierCurveTo(-2, -25, 8, -27, 0, -30);

                        stroke();
                    }

                    ctx.restore();
                }

                // left hand
                if(this.dir.x === -1 || this.dir.x === 0 && this.dir.y === 1){
                    fill(180, 50, 0);
                    ellipse(this.hand2.x, this.hand2.y, 12, 12);
                }

                // health bar
                fill(0);
                ctx.fillRect(-25, -70, 50, 3);

                fill(200, 0, 0);
                if(this.health > 0){
                    ctx.fillRect(-25, -70, this.health * 50 / this.maxHealth, 3);
                }

                // freeze icon
                if(this.frozen){
                    freezeIcon(0, -this.sz * 4);
                }

                ctx.restore();
            };
            Bomber.prototype.update = function(){

                // if it's dead, add loot and remove
                if(this.health <= 0){
                    addMoney(this.gold, this.x, this.y, -this.sz / 2);
                    addEntity(new XP(this.x, this.y, -this.sz, this.xp));
                    player.xp += this.xp;

                    this.on = false;
                    return;
                }
                
                // if it's frozen, move more slowly and take damage
                if(this.frozen > 0){
                    this.speed = this.maxSpeed / 2;
                    this.health -= 0.1;
                    this.frozen--;
                }

                else{
                    this.speed = this.maxSpeed;
                }

                // pick a target
                this.target = this.findTarget();

                // if there's no target, something's gone wrong
                if(!this.target){
                    console.log("No targets found.");
                }
                
                // otherwise, if we're within range of the target and the attacking animation is finished, stop and attack
                else if(distSQ(this.x, this.y, this.target.x, this.target.y) < Math.pow(this.range, 2)){
                    
                    // stop moving
                    this.vel.x = 0;
                    this.vel.y = 0;

                    // the angle to the target
                    this.r = atan2(this.target.y - this.y, this.target.x - this.x);

                    // we're constrained to multiples of 45 degrees for which way to face
                    this.dir.x = this.r < 67.5 || this.r > 292.5 ? 1 : this.r > 112.5 && this.r < 247.5 ? -1 : 0;
                    this.dir.y = this.r > 22.5 && this.r < 157.5 ? 1 : this.r > 202.5 && this.r < 337.5 ? -1 : 0;

                    // fire
                    if(this.cool === 0){
                        addEntity(new GoblinBomb(this.x, this.y, -this.sz / 2, this.target));
                        this.cool = this.maxCool;
                    }
                }

                // otherwise, move towards it
                else if(this.action === "stand"){

                    // stop attacking
                    this.action = "stand";

                    // the angle to the target
                    this.r = atan2(this.target.y - this.y, this.target.x - this.x);

                    // the current angle it's facing
                    let r = atan2(this.dir.y, this.dir.x);

                    // if the angle it's facing is too far away from the angle to the target, turn to face closer
                    if(Math.abs(this.r - r) > 45 && Math.abs((this.r + 180) % 360 - (r + 180) % 360) > 45){

                        // we're constrained to multiples of 45 degrees for which way to face
                        this.dir.x = this.r < 67.5 || this.r > 292.5 ? 1 : this.r > 112.5 && this.r < 247.5 ? -1 : 0;
                        this.dir.y = this.r > 22.5 && this.r < 157.5 ? 1 : this.r > 202.5 && this.r < 337.5 ? -1 : 0;
                    }

                    // set velocity according to direction
                    this.vel.x = this.dir.y === 0 ? this.dir.x * this.speed : this.dir.x * this.speed / rt2;
                    this.vel.y = this.dir.x === 0 ? this.dir.y * this.speed : this.dir.y * this.speed / rt2;

                }
                
                // check for collisions
                this.vel.x = constrain(this.vel.x, this.left ? -Infinity : 0, this.right ? Infinity : 0);
                this.vel.y = constrain(this.vel.y, this.up ? -Infinity : 0, this.down ? Infinity : 0);

                // update previous coordinates
                this.px = this.x;
                this.py = this.y;

                // update coordinates
                this.x += this.vel.x;
                this.y += this.vel.y;

                // update previous action
                this.pAction = this.action;

                // execute action
                this[this.action]();

                // update attack cooldown
                if(this.cool > 0){
                    this.cool--;
                }

            };
            Bomber.prototype.findTarget = function(){

                // loop through all entities
                let closest = castle, dist = distSQ(this.x, this.y, castle.x, castle.y);
                for(let i = 0; i < entities.length; i++){
                    let en = entities[i];

                    // only check the player and decoys
                    if(en.type !== "player" && en.type !== "decoy"){
                        continue;
                    }

                    // the distance to the current entity
                    let curDist = distSQ(this.x, this.y, en.x, en.y);

                    // if this entity is still alive, is within visual range, and is closer than the current closest...
                    if(en.health > 0 && curDist <= Math.pow(this.vis, 2) && curDist < dist){
                        dist = curDist;
                        closest = en;
                    }
                }

                // return the closest entity found, or the castle if none were within visual range
                return closest;

            };
            
            var Miner = function(x, y){

                // entity type
                this.type = "enemy";

                // whether or not it can move
                this.mobile = true;

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;

                // coords from previous frame
                this.px = x;
                this.py = y;

                // velocity
                this.vel = {x: 0, y: 0};

                // which direction it's facing
                this.dir = {x: 0, y: 1};
                this.r = 90;

                // diameter
                this.sz = 60;

                // stats
                this.maxSpeed = 4; // default movement speed
                this.speed = this.maxSpeed; // speed
                this.dmg = 50; // damage
                this.xp = 40; // experience awarded
                this.gold = 15; // sweet, sweet cash
                this.maxHealth = 300; // maximum health
                this.health = this.maxHealth; // health
                this.range = 120; // attack range
                this.vis = 200; // visual range

                // whether or not it's slowed
                this.slowed = false;

                // what it's doing
                this.action = "stand";

                // action from previous frame
                this.pAction = "stand";

                // what it's targeting
                this.target = castle;

                // x- and y-translation
                this.tx = 0;
                this.ty = 0;

                // right hand
                this.hand1 = {
                    x: -25,
                    y: -5,
                    r: 70
                };

                // left hand
                this.hand2 = {
                    x: 20,
                    y: -10
                };

                // sword slash
                let t = this;
                this.slash = {
                    r0: false,
                    r: 0,
                    count: 0,
                    draw: function(){
                        ctx.save();
                        ctx.translate(0, t.hand1.y);
                        ctx.scale(1, 1 / rt3);

                        fill(50, 50);
                        with(ctx){
                            beginPath();

                            moveTo(t.range * cos(this.r), t.range * sin(this.r));
                            arc(0, 0, t.range, angle(this.r), angle(this.r0), true);
                            lineTo(0, 0);

                            fill();
                        }

                        ctx.globalAlpha = 1;

                        ctx.restore();
                    }
                };

                // collision variables
                this.left = true;
                this.right = true;
                this.up = true;
                this.down = true;

                // actions
                this.stand = function(){

                    if(this.dir.x === -1){
                        this.hand1.x = -20;
                        this.hand1.y = -15;
                        this.hand1.r = -30;
                        this.hand1.inFront = false;
                        
                        this.hand2.x = 10;
                        this.hand2.y = -10;
                        this.hand2.inFront = true;
                    }

                    else if(this.dir.x === 1){
                        this.hand1.x = 20;
                        this.hand1.y = -5;
                        this.hand1.r = 30;
                        this.hand1.inFront = true;

                        this.hand2.x = -10;
                        this.hand2.y = -10;
                        this.hand2.inFront = false;
                    }

                    else if(this.dir.y === -1){
                        this.hand1.x = 20;
                        this.hand1.y = -10;
                        this.hand1.r = -50;
                        this.hand1.inFront = false;

                        this.hand2.x = -20;
                        this.hand2.y = -15;
                        this.hand2.inFront = false;
                    }

                    else if(this.dir.y === 1){
                        this.hand1.x = -25;
                        this.hand1.y = -5;
                        this.hand1.r = 70;
                        this.hand1.inFront = true;

                        this.hand2.x = 20;
                        this.hand2.y = -10;
                        this.hand2.inFront = true;
                    }

                    this.slash.r0 = false;
                    this.slash.r = 0;
                    this.slash.count = 0;

                };
                this.attack = function(){

                    if(this.slash.r0 === false){
                        this.slash.r0 = (
                            this.dir.x === 1 ? 0 :
                            this.dir.x === -1 ? 180 :
                            this.dir.y === 1 ? 90 :
                            270
                        );
                    }

                    if(this.slash.r - this.slash.r0 > 360){
                        this.dealDamage();
                        this.action = "stand";
                    }

                    else{
                        this.slash.count++;
                    }
                    
                    this.slash.r = (this.slash.r0 + this.slash.count * 30);
                    
                    this.hand1.r = this.slash.r + 90;
                    this.hand1.inFront = (this.slash.r % 360 <= 180);

                    this.hand1.x = 40 * cos(this.slash.r);
                };
                
            };
            Miner.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3);

                this.slash.draw();

                ctx.scale(1.25, 1.25);

                // shadow
                fill(0, 50);
                ellipse(0, 0, 40, 40 / rt3);

                ctx.translate(this.tx, this.ty);

                // right hand
                if(this.dir.x < 0 || this.dir.x === 0 && this.dir.y === -1){
                    ctx.save();
                    ctx.translate(this.hand1.x, this.hand1.y);
                    ctx.rotate(angle(this.hand1.r));

                    ctx.save();
                    ctx.scale(0.75, 0.75);

                    fill(100, 50, 0);
                    ctx.fillRect(-3, -77, 6, 85);

                    fill(20);
                    with(ctx){
                        beginPath();

                        moveTo(-40, -60);
                        bezierCurveTo(-20, -80, 20, -80, 40, -60);
                        bezierCurveTo(20, -70, -20, -70, -40, -60);

                        fill();
                    }

                    ctx.restore();

                    fill(200, 190, 180);
                    ellipse(0, 0, 12, 12);

                    ctx.restore();
                }

                // left hand
                if(this.dir.x > 0 || this.dir.x === 0 && this.dir.y === -1){
                    fill(200, 190, 180);
                    ellipse(this.hand2.x, this.hand2.y, 12, 12);
                }

                // body
                fill(200, 190, 180);
                ellipse(0, -20, 40, 40);

                // cap
                fill(100);
                with(ctx){
                    beginPath();

                    moveTo(-18, -30);
                    bezierCurveTo(-10, -45, 10, -45, 18, -30);
                    bezierCurveTo(10, -25, -10, -25, -18, -30);

                    fill();
                }

                // eyes
                fill(0);

                if(this.dir.x === -1){
                    ellipse(-10, -25, 3, 3);
                }

                else if(this.dir.x === 1){
                    ellipse(10, -25, 3, 3);
                }

                else if(this.dir.y === 1){
                    ellipse(-6, -25, 3, 3);
                    ellipse(6, -25, 3, 3);
                }

                // clothes
                fill(100, 50, 0);
                with(ctx){
                    beginPath();

                    moveTo(0, -20);
                    arc(0, -20, 20, angle(180), 0, true);
                    bezierCurveTo(8, -12, -8, -12, -20, -20);

                    fill();
                }

                // right hand
                if(this.dir.x > 0 || this.dir.x === 0 && this.dir.y === 1){
                    ctx.save();
                    ctx.translate(this.hand1.x, this.hand1.y);
                    ctx.rotate(angle(this.hand1.r));

                    ctx.save();
                    ctx.scale(0.5, 0.5);

                    fill(100, 50, 0);
                    ctx.fillRect(-3, -77, 6, 85);

                    fill(20);
                    with(ctx){
                        beginPath();

                        moveTo(-40, -60);
                        bezierCurveTo(-20, -80, 20, -80, 40, -60);
                        bezierCurveTo(20, -70, -20, -70, -40, -60);

                        fill();
                    }

                    ctx.restore();

                    fill(200, 190, 180);
                    ellipse(0, 0, 12, 12);

                    ctx.restore();
                }

                // left hand
                if(this.dir.x === -1 || this.dir.x === 0 && this.dir.y === 1){
                    fill(200, 190, 180);
                    ellipse(this.hand2.x, this.hand2.y, 12, 12);
                }

                // health bar
                fill(0);
                ctx.fillRect(-25, -70, 50, 3);

                fill(200, 0, 0);
                if(this.health > 0){
                    ctx.fillRect(-25, -70, this.health * 50 / this.maxHealth, 3);
                }

                // freeze icon
                if(this.frozen){
                    freezeIcon(0, -this.sz * 1.75);
                }

                ctx.restore();
            };
            Miner.prototype.update = function(){

                // if it's dead, add loot and remove
                if(this.health <= 0){
                    addMoney(this.gold, this.x, this.y, -this.sz / 2);
                    addEntity(new XP(this.x, this.y, -this.sz, this.xp));
                    player.xp += this.xp;

                    this.on = false;
                    return;
                }

                // if it's frozen, move more slowly and take damage
                if(this.frozen > 0){
                    this.speed = this.maxSpeed / 2;
                    this.health -= 0.1;
                    this.frozen--;
                }

                else{
                    this.speed = this.maxSpeed;
                }

                // pick a target
                this.target = this.findTarget();

                // if there's no target, something's gone wrong
                if(!this.target){
                    console.log("No targets found.");
                }

                // otherwise, if we're within range of the target and the attacking animation is finished, stop and attack
                else if(distSQ(this.x, this.y, this.target.x, this.target.y) < Math.pow(this.range, 2)){
                    if(this.action !== "attack" && this.pAction !== "attack"){
                        this.vel.x = 0;
                        this.vel.y = 0;
                        
                        this.action = "attack";
                    }
                }

                // otherwise, move towards it
                else if(this.action === "stand"){

                    // stop attacking
                    this.action = "stand";

                    // the angle to the target
                    this.r = atan2(this.target.y - this.y, this.target.x - this.x);

                    // the current angle it's facing
                    let r = atan2(this.dir.y, this.dir.x);

                    // if the angle it's facing is too far away from the angle to the target, turn to face closer
                    if(Math.abs(this.r - r) > 45 && Math.abs((this.r + 180) % 360 - (r + 180) % 360) > 45){

                        // we're constrained to multiples of 45 degrees for which way to face
                        this.dir.x = this.r < 67.5 || this.r > 292.5 ? 1 : this.r > 112.5 && this.r < 247.5 ? -1 : 0;
                        this.dir.y = this.r > 22.5 && this.r < 157.5 ? 1 : this.r > 202.5 && this.r < 337.5 ? -1 : 0;
                    }

                    // set velocity according to direction
                    this.vel.x = this.dir.y === 0 ? this.dir.x * this.speed : this.dir.x * this.speed / rt2;
                    this.vel.y = this.dir.x === 0 ? this.dir.y * this.speed : this.dir.y * this.speed / rt2;

                }

                // check for collisions
                this.vel.x = constrain(this.vel.x, this.left ? -Infinity : 0, this.right ? Infinity : 0);
                this.vel.y = constrain(this.vel.y, this.up ? -Infinity : 0, this.down ? Infinity : 0);

                // update previous coordinates
                this.px = this.x;
                this.py = this.y;

                // update coordinates
                this.x += this.vel.x;
                this.y += this.vel.y;

                // update previous action
                this.pAction = this.action;

                // execute action
                this[this.action]();

            };
            Miner.prototype.findTarget = function(){

                // loop through all entities
                let closest = castle, dist = distSQ(this.x, this.y, castle.x, castle.y);
                for(let i = 0; i < entities.length; i++){
                    let en = entities[i];

                    // only check towers, the player, and decoys
                    if(en.type !== "tower" && en.type !== "player" && en.type !== "decoy"){
                        continue;
                    }

                    // the distance to the current entity
                    let curDist = distSQ(this.x, this.y, en.x, en.y);

                    // if this entity is still alive, is within visual range, and is closer than the current closest...
                    if(en.health > 0 && curDist <= Math.pow(this.vis, 2) && curDist < dist){
                        dist = curDist;
                        closest = en;
                    }
                }

                // return the closest entity found, or the castle if none were within visual range
                return closest;

            };
            Miner.prototype.dealDamage = function(){

                // loop through all entities
                for(let i = 0; i < entities.length; i++){
                    let en = entities[i];

                    // only damage towers, the player, the castle, and decoys
                    if(en.type !== "tower" && en.type !== "castle" && en.type !== "decoy" && en.type !== "player"){
                        continue;
                    }

                    // deal damage to the enemy if it's within range
                    if(distSQ(this.x, this.y, en.x, en.y) <= Math.pow(this.range, 2)){
                        en.health -= this.dmg;
                    }
                }
            };

            var Alpha = function(x, y){

                // entity type
                this.type = "enemy";

                // whether or not it can move
                this.mobile = true;

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;

                // coords from previous frame
                this.px = x;
                this.py = y;

                // velocity
                this.vel = {x: 0, y: 0};

                // which direction it's facing
                this.dir = {x: 0, y: 1};
                this.r = 90;

                // diameter
                this.sz = 40;

                // stats
                this.maxSpeed = 3; // default movement speed
                this.speed = this.maxSpeed; // speed
                this.xp = 100; // experience awarded
                this.gold = 30; // sweet, sweet cash
                this.health = 2000; // health
                this.maxHealth = 2000; // maximum health
                this.range = 240; // attack range
                this.vis = 1500; // visual range
                this.maxCool = 180; // attack cooldown
                this.cool = this.maxCool; // how long until it can attack

                // whether or not it's slowed
                this.slowed = false;

                // what it's doing
                this.action = "stand";

                // action from previous frame
                this.pAction = "stand";

                // what it's targeting
                this.target = castle;

                // x- and y-translation
                this.tx = 0;
                this.ty = 0;

                // right hand
                this.hand1 = {
                    x: -25,
                    y: -5,
                    r: 70
                };

                // left hand
                this.hand2 = {
                    x: 20,
                    y: -10
                };

                // collision variables
                this.left = true;
                this.right = true;
                this.up = true;
                this.down = true;

                // actions
                this.stand = function(){

                    if(this.dir.x === -1){
                        this.hand1.x = -15;
                        this.hand1.y = -15;
                        this.hand1.r = -30;
                        this.hand1.inFront = false;
                        
                        this.hand2.x = 10;
                        this.hand2.y = -10;
                        this.hand2.inFront = true;
                    }

                    else if(this.dir.x === 1){
                        this.hand1.x = 15;
                        this.hand1.y = -5;
                        this.hand1.r = 30;
                        this.hand1.inFront = true;

                        this.hand2.x = -10;
                        this.hand2.y = -10;
                        this.hand2.inFront = false;
                    }

                    else if(this.dir.y === -1){
                        this.hand1.x = 20;
                        this.hand1.y = -15;
                        this.hand1.r = -0;
                        this.hand1.inFront = false;

                        this.hand2.x = -20;
                        this.hand2.y = -15;
                        this.hand2.inFront = false;
                    }

                    else if(this.dir.y === 1){
                        this.hand1.x = -20;
                        this.hand1.y = -10;
                        this.hand1.r = 20;
                        this.hand1.inFront = true;

                        this.hand2.x = 20;
                        this.hand2.y = -10;
                        this.hand2.inFront = true;
                    }

                };
                
            };
            Alpha.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3);

                ctx.scale(2, 2);

                // shadow
                fill(0, 50);
                ellipse(0, 0, 40, 40 / rt3);

                ctx.translate(this.tx, this.ty);

                // right hand
                if(this.dir.x < 0 || this.dir.x === 0 && this.dir.y === -1){
                    ctx.save();
                    ctx.translate(this.hand1.x, this.hand1.y);
                    ctx.rotate(angle(this.hand1.r));

                    fill(120, 0, 160);
                    ellipse(0, 0, 12, 12);

                    ctx.restore();
                }

                // left hand
                if(this.dir.x > 0 || this.dir.x === 0 && this.dir.y === -1){
                    fill(120, 0, 160);
                    ellipse(this.hand2.x, this.hand2.y, 12, 12);
                }

                // body
                fill(120, 0, 160);
                ellipse(0, -20, 40, 40);

                // eyes
                fill(200, 200, 0);

                if(this.dir.x === -1){
                    ellipse(-10, -25, 4, 4);
                }

                else if(this.dir.x === 1){
                    ellipse(10, -25, 4, 4);
                }

                else if(this.dir.y === 1){
                    ellipse(-6, -25, 4, 4);
                    ellipse(6, -25, 4, 4);
                }

                // clothes
                fill(80, 30, 80);
                with(ctx){
                    beginPath();

                    moveTo(0, -20);
                    arc(0, -20, 20, angle(180), 0, true);
                    bezierCurveTo(8, -12, -8, -12, -20, -20);

                    fill();
                }

                // right hand
                if(this.dir.x > 0 || this.dir.x === 0 && this.dir.y === 1){
                    ctx.save();
                    ctx.translate(this.hand1.x, this.hand1.y);
                    ctx.rotate(angle(this.hand1.r));

                    fill(120, 0, 160);
                    ellipse(0, 0, 12, 12);

                    ctx.restore();
                }

                // left hand
                if(this.dir.x === -1 || this.dir.x === 0 && this.dir.y === 1){
                    fill(120, 0, 160);
                    ellipse(this.hand2.x, this.hand2.y, 12, 12);
                }

                // health bar
                fill(0);
                ctx.fillRect(-25, -70, 50, 3);

                fill(200, 0, 0);
                if(this.health > 0){
                    ctx.fillRect(-25, -70, this.health * 50 / this.maxHealth, 3);
                }

                // freeze icon
                if(this.frozen){
                    freezeIcon(0, -this.sz * 2.5);
                }

                ctx.restore();
            };
            Alpha.prototype.update = function(){
                
                // if it's dead, add loot and remove
                if(this.health <= 0){
                    addMoney(this.gold, this.x, this.y, -this.sz / 2);
                    addEntity(new XP(this.x, this.y, -this.sz, this.xp));
                    player.xp += this.xp;

                    this.on = false;
                    return;
                }
                
                // if it's frozen, move more slowly and take damage
                if(this.frozen > 0){
                    this.speed = this.maxSpeed / 2;
                    this.health -= 0.1;
                    this.frozen--;
                }

                else{
                    this.speed = this.maxSpeed;
                }

                // always move towards the castle
                this.target = castle;
                
                // if the attack cooldown is done, stop and attack
                if(this.cool === 0 || this.cool > this.maxCool - 30){
                    
                    // stop moving
                    this.vel.x = 0;
                    this.vel.y = 0;

                    // summon lightning
                    if(this.cool === 0){
                        addEntity(new Lightning(this.x + this.range * cos(this.r), this.y + this.range * sin(this.r)));
                        addEntity(new Lightning(this.x + this.range * cos(this.r + 120), this.y + this.range * sin(this.r + 120)));
                        addEntity(new Lightning(this.x + this.range * cos(this.r + 240), this.y + this.range * sin(this.r + 240)));

                        this.cool = this.maxCool;
                    }
                }

                // otherwise, move towards it
                else if(this.action === "stand"){

                    // stop attacking
                    this.action = "stand";

                    // only move if it's not close enough
                    if(distSQ(this.x, this.y, this.target.x, this.target.y) > Math.pow(this.range, 2)){

                        // the angle to the target
                        this.r = atan2(this.target.y - this.y, this.target.x - this.x);

                        // the current angle it's facing
                        let r = atan2(this.dir.y, this.dir.x);

                        // if the angle it's facing is too far away from the angle to the target, turn to face closer
                        if(Math.abs(this.r - r) > 45 && Math.abs((this.r + 180) % 360 - (r + 180) % 360) > 45){

                            // we're constrained to multiples of 45 degrees for which way to face
                            this.dir.x = this.r < 67.5 || this.r > 292.5 ? 1 : this.r > 112.5 && this.r < 247.5 ? -1 : 0;
                            this.dir.y = this.r > 22.5 && this.r < 157.5 ? 1 : this.r > 202.5 && this.r < 337.5 ? -1 : 0;
                        }

                        // set velocity according to direction
                        this.vel.x = this.dir.y === 0 ? this.dir.x * this.speed : this.dir.x * this.speed / rt2;
                        this.vel.y = this.dir.x === 0 ? this.dir.y * this.speed : this.dir.y * this.speed / rt2;
                    }

                    else{
                        this.vel.x = 0;
                        this.vel.y = 0;
                    }

                }

                // update previous coordinates
                this.px = this.x;
                this.py = this.y;

                // update coordinates
                this.x += this.vel.x;
                this.y += this.vel.y;

                // update previous action
                this.pAction = this.action;

                // execute action
                this[this.action]();

                // update attack cooldown
                if(this.cool > 0){
                    this.cool--;
                }

            };

        </script>
        
        <!-- missiles -->
        <script>
            var Arrow = function(x, y, z, targ){

                // entity type
                this.type = "missile";

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;
                this.z = z;
                
                // coordinates from previous frame
                this.px = x;
                this.py = y;
                this.pz = z;

                // stats
                this.dmg = 10; // damage
                this.speed = 20; // speed
                this.grav = 0.5; // acceleration due to gravity

                // whether or not it's hit anything yet
                this.hit = false;

                // transparency
                this.t = 255;

                // calculate the distance to target
                let dist = Math.sqrt(distSQ(this.x, this.y, targ.x, targ.y));

                // calculate time taken to reach target
                let time = dist / this.speed;

                // calculate target position based on where the target will be by the time the arrow hits
                this.targ = {
                    x: targ.x + targ.vel.x * time,
                    y: targ.y + targ.vel.y * time
                };

                // calculate rotation in xy-plane
                this.r = atan2(this.targ.y - this.y, this.targ.x - this.x);

                // calculate velocity
                this.vel = {
                    x: this.speed * cos(this.r),
                    y: this.speed * sin(this.r),
                    z: -(this.z + targ.sz / 2) / time - (this.grav * time / 2)
                };

            };
            Arrow.prototype.draw = function(){
                
                // calculate perceived y-velocity
                let yVel = this.vel.y / rt3 + this.vel.z;

                ctx.save();
                ctx.translate(this.x, this.y / rt3 + this.z);
                ctx.rotate(angle(atan2(yVel, this.vel.x)));

                // the shaft
                fill(100, 50, 0, this.t);
                ctx.fillRect(-30, -1, 25, 2);

                // the head and tail
                fill(0, this.t);
                with(ctx){
                    beginPath();

                    moveTo(0, 0);
                    lineTo(-5, -2);
                    lineTo(-5, 2);

                    moveTo(-25, 0);
                    lineTo(-27, -2);
                    lineTo(-32, -2);
                    lineTo(-30, 0);
                    lineTo(-32, 2);
                    lineTo(-27, 2);

                    fill();
                }

                ctx.globalAlpha = 1;

                ctx.restore();
            };
            Arrow.prototype.update = function(){
                
                // if it hasn't hit the ground yet...
                if(this.z < 0){

                    // accelerate towards the ground
                    this.vel.z += this.grav;

                    // update previous coords
                    this.px = this.x;
                    this.py = this.y;
                    this.pz = this.z;

                    // update position
                    this.x += this.vel.x;
                    this.y += this.vel.y;
                    this.z += this.vel.z;

                    // check for collisions
                    for(let i = 0; i < entities.length; i++){
                        let en = entities[i];

                        // only collide with enemies
                        if(en.type !== "enemy"){
                            continue;
                        }

                        // the slope of travel on the xy-plane
                        let slope = (this.y - this.py) / (this.x - this.px);

                        // find the closest the arrow hypothetically got to the target between the last frame and this one (Trust me, I did the math. Or don't trust me and do it yourself: all you have to do is find the parametric equation of the line between the current coords and previous coords, form an expression for the distance between an arbitrary point on that line and the target coords, differentiate that expression with respect to the parameter, set the derivative equal to zero, and solve the resulting equation to find the value of the parameter that minimizes the distance between the corresponding point on the line and the target coords. Up to you.)
                        let t = -((this.px - en.x) + slope * (this.py - en.y)) / (Math.pow(slope, 2) + 1),
                            x = this.px + t,
                            y = this.py + t * slope;
                        
                        // if it's close enough to hit, deal damage and delete
                        if(t >= 0 && t <= Math.abs(this.px - this.x) && this.z > -en.sz * 2 && distSQ(x, y, en.x, en.y) < Math.pow(en.sz / 2, 2)){
                            this.dealDamage(en);
                            this.on = false;
                            break;
                        }
                    }
                }
                
                else{
                    this.z = 0;
                    
                    this.t -= 5;
                    if(this.t <= 0){
                        this.on = false;
                    }
                }

            };
            Arrow.prototype.dealDamage = function(entity){
                
                // only damage mobile units (enemies, players, and decoys)
                if(entity.mobile){
                    entity.health -= this.dmg;
                }
            };

            var Bomb = function(x, y, z, targ){

                // entity type
                this.type = "missile";

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;
                this.z = z;
                
                // coordinates from previous frame
                this.px = x;
                this.py = y;
                this.pz = z;

                // stats
                this.dmg = 30; // damage
                this.aoe = 150; // area of effect radius
                this.speed = 15; // speed
                this.grav = 0.8; // acceleration due to gravity

                // whether it's hit anything yet
                this.hit = false;

                // calculate the distance to target
                let dist = Math.sqrt(distSQ(this.x, this.y, targ.x, targ.y));

                // calculate time taken to reach target
                let time = dist / this.speed;

                // calculate target position based on where the target will be by the time the bomb hits
                this.targ = {
                    x: targ.x + targ.vel.x * time,
                    y: targ.y + targ.vel.y * time
                };

                // calculate rotation in xy-plane
                this.r = atan2(this.targ.y - this.y, this.targ.x - this.x);

                // calculate velocity
                this.vel = {
                    x: this.speed * cos(this.r),
                    y: this.speed * sin(this.r),
                    z: (-this.z / time) - (this.grav * time / 2)
                };

                // explosion particles
                this.part = (function(){
                    let array = [];

                    // AOE
                    array.push({
                        x: 0, y: 0, // coords
                        s: 0, // size
                        t: 255, // transparency
                        type: 2 // type
                    });

                    // smoke particles
                    for(let i = 0; i < 100; i++){
                        let r = 360 * Math.random(),
                            d = 5 * Math.random(),
                            s = -8 + 16 * Math.random();

                        array.push({
                            x: d * cos(r), y: d * sin(r), z: 0, // coords
                            vel: {
                                x: s * cos(r), // x-velocity
                                y: s * sin(r), // y-velocity
                                z: -10 - 20 * Math.random() // z-velocity
                            },
                            s: 2 + 3 * Math.random(), // diameter
                            t: 255, // transparency
                            c: Math.round(80 + 30 * Math.random()), // color
                            tSpeed: 6 + 8 * Math.random(), // rate at which transparency decreases
                            type: 0 // type
                        });
                    }

                    // sparks
                    for(let i = 0; i < 5; i++){
                        let r = 360 * Math.random(),
                            s = 2 + 8 * Math.random();

                        array.push({
                            x: 5 * cos(r), y: 5 * sin(r), z: 0, // coords
                            vel: {
                                x: s * cos(r), // x-velocity
                                y: s * sin(r), // y-velocity
                                z: -8 - 7 * Math.random() // z-velocity
                            },
                            type: 1 // type
                        });
                    }

                    return array;
                })();
            };
            Bomb.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3 + this.z);

                // explosion
                if(this.hit){
                    for(let i = 0; i < this.part.length; i++){
                        let part = this.part[i];

                        if(part.type === 0){

                            part.vel.x = lerp(part.vel.x, 0, 0.02);
                            part.vel.y = lerp(part.vel.y, 0, 0.02);
                            part.vel.z = lerp(part.vel.z, 0, -part.z / 500);

                            part.x += part.vel.x;
                            part.y += part.vel.y;
                            part.z += part.vel.z;

                            part.s += 1.2;
                            part.t -= part.tSpeed;

                            if(part.t <= 0){
                                this.part.splice(i, 1);
                                i--;

                                continue;
                            }

                            fill(part.c, part.t);
                            ellipse(part.x, part.y / rt3 + part.z, part.s, part.s);
                        }

                        else if(part.type === 1){
                            part.vel.z += 0.5;

                            part.x += part.vel.x;
                            part.y += part.vel.y;
                            part.z += part.vel.z;

                            if(part.z >= 0){
                                this.part.splice(i, 1);
                                i--;

                                continue;
                            }

                            fill(255, 255, 0);
                            ellipse(part.x, part.y / rt3 + part.z, 2, 2);
                        }

                        else{
                            part.s = lerp(part.s, this.aoe * 2, 0.1);
                            part.t -= 5;

                            fill(255, 100, 0, part.t);
                            ellipse(part.x, part.y, part.s, part.s / rt3);

                            if(part.t <= 0){
                                this.part.splice(i, 1);
                                i--;

                                continue;
                            }
                        }
                    }
                }

                // normal
                else{
                    fill(20);
                    ellipse(0, 0, 10, 10);
                }

                ctx.restore();
            };
            Bomb.prototype.update = function(){
                
                // if it hasn't hit the ground yet...
                if(this.z < 0){

                    // accelerate towards the ground
                    this.vel.z += this.grav;

                    // update previous coords
                    this.px = this.x;
                    this.py = this.y;
                    this.pz = this.z;

                    // update position
                    this.x += this.vel.x;
                    this.y += this.vel.y;
                    this.z += this.vel.z;
                }

                // otherwise, explode
                else if(!this.hit){
                    this.dealDamage();
                    this.hit = true;
                    this.z = 0;
                }

                // remove if explosion is finished
                if(this.hit && this.part.length === 0){
                    this.on = false;
                }

            };
            Bomb.prototype.dealDamage = function(){

                    // loop through all entities
                    for(let i = 0; i < entities.length; i++){
                        let en = entities[i];

                        // only damage enemies
                        if(en.type !== "enemy"){
                            continue;
                        }

                        // deal damage to the enemy if it's within range
                        if(distSQ(this.x, this.y, en.x, en.y) <= Math.pow(this.aoe, 2)){
                            en.health -= this.dmg;
                        }
                    }
            };

            var Bolt = function(x, y, z, targ){

                // entity type
                this.type = "missile";

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;
                this.z = z;
                
                // coordinates from previous frame
                this.px = x;
                this.py = y;
                this.pz = z;

                // stats
                this.dmg = 60; // damage
                this.speed = 50; // speed
                this.grav = 0.75; // acceleration due to gravity

                // whether or not it's hit anything yet
                this.hit = false;

                // transparency
                this.t = 255;

                // calculate the distance to target
                let dist = Math.sqrt(distSQ(this.x, this.y, targ.x, targ.y));

                // calculate time taken to reach target
                let time = dist / this.speed;

                // calculate target position based on where the target will be by the time the arrow hits
                this.targ = {
                    x: targ.x + targ.vel.x * time,
                    y: targ.y + targ.vel.y * time
                };

                // calculate rotation in xy-plane
                this.r = atan2(this.targ.y - this.y, this.targ.x - this.x);

                // calculate velocity
                this.vel = {
                    x: this.speed * cos(this.r),
                    y: this.speed * sin(this.r),
                    z: -(this.z + targ.sz / 2) / time - (this.grav * time / 2)
                };

            };
            Bolt.prototype.draw = function(){

                // calculate perceived y-velocity
                let yVel = this.vel.y / rt3 + this.vel.z;

                ctx.save();
                ctx.translate(this.x, this.y / rt3 + this.z);
                ctx.rotate(angle(atan2(yVel, this.vel.x)));

                // the shaft
                fill(0, this.t);
                ctx.fillRect(-50, -1.5, 40, 3);

                // the head and tail
                fill(0, this.t);
                with(ctx){
                    beginPath();

                    moveTo(0, 0);
                    lineTo(-10, -4);
                    lineTo(-10, 4);

                    moveTo(-40, 0);
                    lineTo(-45, -5);
                    lineTo(-55, -5);
                    lineTo(-50, 0);
                    lineTo(-55, 5);
                    lineTo(-45, 5);

                    fill();
                }

                ctx.globalAlpha = 1;

                ctx.restore();
            };
            Bolt.prototype.update = function(){

                // if it hasn't hit the ground yet...
                if(this.z < 0){

                    // accelerate towards the ground
                    this.vel.z += this.grav;

                    // update previous coords
                    this.px = this.x;
                    this.py = this.y;
                    this.pz = this.z;

                    // update position
                    this.x += this.vel.x;
                    this.y += this.vel.y;
                    this.z += this.vel.z;

                    // check for collisions
                    for(let i = 0; i < entities.length; i++){
                        let en = entities[i];

                        // only collide with enemies
                        if(en.type !== "enemy"){
                            continue;
                        }

                        // the slope of travel on the xy-plane
                        let slope = (this.y - this.py) / (this.x - this.px);

                        // find the closest the bolt hypothetically got to the target between the last frame and this one (Trust me, I did the math. Or don't trust me and do it yourself: all you have to do is find the parametric equation of the line between the current coords and previous coords, form an expression for the distance between an arbitrary point on that line and the target coords, differentiate that expression with respect to the parameter, set the derivative equal to zero, and solve the resulting equation to find the value of the parameter that minimizes the distance between the corresponding point on the line and the target coords. Up to you.)
                        let t = -((this.px - en.x) + slope * (this.py - en.y)) / (Math.pow(slope, 2) + 1),
                            x = this.px + t,
                            y = this.py + t * slope;

                        
                        // if it's close enough to hit, deal damage and delete
                        if(t >= 0 && t <= Math.abs(this.px - this.x) && this.z > -en.sz && distSQ(x, y, en.x, en.y) < Math.pow(en.sz / 2, 2)){
                            this.dealDamage(en);
                            this.on = false;
                            break;
                        }
                    }
                }

                else{
                    this.z = 0;

                    this.t -= 5;
                    if(this.t <= 0){
                        this.on = false;
                    }
                }

            };
            Bolt.prototype.dealDamage = function(entity){

                // only damage mobile units (enemies, players, and decoys)
                if(entity.mobile){
                    entity.health -= this.dmg;
                }
            };

            var GoblinBomb = function(x, y, z, targ){

                // entity type
                this.type = "missile";

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;
                this.z = z;
                
                // coordinates from previous frame
                this.px = x;
                this.py = y;
                this.pz = z;

                // stats
                this.dmg = 20; // damage
                this.aoe = 100; // area of effect radius
                this.speed = 15; // speed
                this.grav = 0.8; // acceleration due to gravity

                // whether it's hit anything yet
                this.hit = false;

                // calculate the distance to target
                let dist = Math.sqrt(distSQ(this.x, this.y, targ.x, targ.y));

                // calculate time taken to reach target
                let time = dist / this.speed;

                // calculate target position based on where the target will be by the time the bomb hits
                this.targ = {
                    x: targ.x + targ.vel.x * time,
                    y: targ.y + targ.vel.y * time
                };

                // calculate rotation in xy-plane
                this.r = atan2(this.targ.y - this.y, this.targ.x - this.x);

                // calculate velocity
                this.vel = {
                    x: this.speed * cos(this.r),
                    y: this.speed * sin(this.r),
                    z: (-this.z / time) - (this.grav * time / 2)
                };

                // explosion particles
                this.part = (function(){
                    let array = [];

                    // AOE
                    array.push({
                        x: 0, y: 0, // coords
                        s: 0, // size
                        t: 255, // transparency
                        type: 2 // type
                    });

                    // smoke particles
                    for(let i = 0; i < 50; i++){
                        let r = 360 * Math.random(),
                            d = 5 * Math.random(),
                            s = -8 + 16 * Math.random();

                        array.push({
                            x: d * cos(r), y: d * sin(r), z: 0, // coords
                            vel: {
                                x: s * cos(r), // x-velocity
                                y: s * sin(r), // y-velocity
                                z: -10 - 20 * Math.random() // z-velocity
                            },
                            s: 2 + 3 * Math.random(), // diameter
                            t: 255, // transparency
                            c: Math.round(80 + 30 * Math.random()), // color
                            tSpeed: 6 + 8 * Math.random(), // rate at which transparency decreases
                            type: 0 // type
                        });
                    }

                    // sparks
                    for(let i = 0; i < 5; i++){
                        let r = 360 * Math.random(),
                            s = 2 + 8 * Math.random();

                        array.push({
                            x: 5 * cos(r), y: 5 * sin(r), z: 0, // coords
                            vel: {
                                x: s * cos(r), // x-velocity
                                y: s * sin(r), // y-velocity
                                z: -8 - 7 * Math.random() // z-velocity
                            },
                            type: 1 // type
                        });
                    }

                    return array;
                })();
            };
            GoblinBomb.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3 + this.z);
                ctx.scale(2/3, 2/3);

                // explosion
                if(this.hit){
                    for(let i = 0; i < this.part.length; i++){
                        let part = this.part[i];

                        if(part.type === 0){

                            part.vel.x = lerp(part.vel.x, 0, 0.02);
                            part.vel.y = lerp(part.vel.y, 0, 0.02);
                            part.vel.z = lerp(part.vel.z, 0, -part.z / 500);

                            part.x += part.vel.x;
                            part.y += part.vel.y;
                            part.z += part.vel.z;

                            part.s += 1.2;
                            part.t -= part.tSpeed;

                            if(part.t <= 0){
                                this.part.splice(i, 1);
                                i--;

                                continue;
                            }

                            fill(part.c, part.t);
                            ellipse(part.x, part.y / rt3 + part.z, part.s, part.s);
                        }

                        else if(part.type === 1){
                            part.vel.z += 0.5;

                            part.x += part.vel.x;
                            part.y += part.vel.y;
                            part.z += part.vel.z;

                            if(part.z >= 0){
                                this.part.splice(i, 1);
                                i--;

                                continue;
                            }

                            fill(0, 255, 255);
                            ellipse(part.x, part.y / rt3 + part.z, 2, 2);
                        }

                        else{
                            part.s = lerp(part.s, this.aoe * 3, 0.1);
                            part.t -= 5;

                            fill(0, 100, 255, part.t);
                            ellipse(part.x, part.y, part.s, part.s / rt3);

                            if(part.t <= 0){
                                this.part.splice(i, 1);
                                i--;

                                continue;
                            }
                        }
                    }
                }

                // normal
                else{
                    fill(20);
                    ellipse(0, 0, 10, 10);
                }

                ctx.restore();
            };
            GoblinBomb.prototype.update = function(){
                
                // if it hasn't hit the ground yet...
                if(this.z < 0){

                    // accelerate towards the ground
                    this.vel.z += this.grav;

                    // update previous coords
                    this.px = this.x;
                    this.py = this.y;
                    this.pz = this.z;

                    // update position
                    this.x += this.vel.x;
                    this.y += this.vel.y;
                    this.z += this.vel.z;
                }

                // otherwise, explode
                else if(!this.hit){
                    this.dealDamage();
                    this.hit = true;
                    this.z = 0;
                }

                // remove if explosion is finished
                if(this.hit && this.part.length === 0){
                    this.on = false;
                }

            };
            GoblinBomb.prototype.dealDamage = function(){

                // loop through all entities
                for(let i = 0; i < entities.length; i++){
                    let en = entities[i];

                    // only damage mobile units plus the castle (the player, enemies, and decoys)
                    if(!en.mobile && en.type !== "castle"){
                        continue;
                    }

                    // deal damage to the enemy if it's within range
                    if(distSQ(this.x, this.y, en.x, en.y) <= Math.pow(this.aoe, 2)){
                        en.health -= this.dmg;
                    }
                }
            };

            var GoblinArrow = function(x, y, z, targ){

                // entity type
                this.type = "missile";

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;
                this.z = z;
                
                // coordinates from previous frame
                this.px = x;
                this.py = y;
                this.pz = z;

                // stats
                this.dmg = 10; // damage
                this.speed = 20; // speed
                this.grav = 0.5; // acceleration due to gravity

                // whether or not it's hit anything yet
                this.hit = false;

                // transparency
                this.t = 255;

                // calculate the distance to target
                let dist = Math.sqrt(distSQ(this.x, this.y, targ.x, targ.y));

                // calculate time taken to reach target
                let time = dist / this.speed;

                // calculate target position based on where the target will be by the time the arrow hits
                this.targ = {
                    x: targ.x + targ.vel.x * time,
                    y: targ.y + targ.vel.y * time
                };

                // calculate rotation in xy-plane
                this.r = atan2(this.targ.y - this.y, this.targ.x - this.x);

                // calculate velocity
                this.vel = {
                    x: this.speed * cos(this.r),
                    y: this.speed * sin(this.r),
                    z: -(this.z + targ.sz / 2) / time - (this.grav * time / 2)
                };

            };
            GoblinArrow.prototype.draw = function(){

                // calculate perceived y-velocity
                let yVel = this.vel.y / rt3 + this.vel.z;

                ctx.save();
                ctx.translate(this.x, this.y / rt3 + this.z);
                ctx.rotate(angle(atan2(yVel, this.vel.x)));
                ctx.scale(0.75, 0.75);

                // the shaft
                fill(100, 50, 0, this.t);
                ctx.fillRect(-30, -1, 25, 2);

                // the head and tail
                fill(0, this.t);
                with(ctx){
                    beginPath();

                    moveTo(0, 0);
                    lineTo(-5, -2);
                    lineTo(-5, 2);

                    moveTo(-25, 0);
                    lineTo(-27, -2);
                    lineTo(-32, -2);
                    lineTo(-30, 0);
                    lineTo(-32, 2);
                    lineTo(-27, 2);

                    fill();
                }

                ctx.globalAlpha = 1;

                ctx.restore();
            };
            GoblinArrow.prototype.update = function(){

                // if it hasn't hit the ground yet...
                if(this.z < 0){

                    // accelerate towards the ground
                    this.vel.z += this.grav;

                    // update previous coords
                    this.px = this.x;
                    this.py = this.y;
                    this.pz = this.z;

                    // update position
                    this.x += this.vel.x;
                    this.y += this.vel.y;
                    this.z += this.vel.z;

                    // check for collisions
                    for(let i = 0; i < entities.length; i++){
                        let en = entities[i];

                        // don't collide with towers or enemies
                        if(en.type === "tower" || en.type === "enemy"){
                            continue;
                        }

                        // the slope of travel on the xy-plane
                        let slope = (this.y - this.py) / (this.x - this.px);

                        // find the closest the arrow hypothetically got to the target between the last frame and this one (Trust me, I did the math. Or don't trust me and do it yourself: all you have to do is find the parametric equation of the line between the current coords and previous coords, form an expression for the distance between an arbitrary point on that line and the target coords, differentiate that expression with respect to the parameter, set the derivative equal to zero, and solve the resulting equation to find the value of the parameter that minimizes the distance between the corresponding point on the line and the target coords. Up to you.)
                        let t = -((this.px - en.x) + slope * (this.py - en.y)) / (Math.pow(slope, 2) + 1),
                            x = this.px + t,
                            y = this.py + t * slope;
                        
                        // if it's close enough to hit, deal damage and delete
                        if(t >= 0 && t <= Math.abs(this.px - this.x) && this.z > -en.sz * 2 && distSQ(x, y, en.x, en.y) < Math.pow(en.sz / 2, 2)){
                            this.dealDamage(en);
                            this.on = false;
                            break;
                        }
                    }
                }
                
                else{
                    this.z = 0;
                    
                    this.t -= 5;
                    if(this.t <= 0){
                        this.on = false;
                    }
                }

            };
            GoblinArrow.prototype.dealDamage = function(entity){
                                
                // only damage mobile units (enemies, players, and decoys) or the castle
                if(entity.mobile || entity.type === "castle"){
                    entity.health -= this.dmg;
                }
            };

            var Lightning = function(x, y){
                
                // entity type
                this.type = "missile";

                // whether or not it still exists
                this.on = true;

                // coordinates
                this.x = x;
                this.y = y;

                // stats
                this.dmg = 100; // damage
                this.aoe = 200; // aoe radius

                // timer
                this.maxTime = 40;
                this.timer = this.maxTime;

                // aoe indicator size and transparency
                this.s = 0;
                this.t = 255;

            };
            Lightning.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3);

                if(this.t > 0){
                    fill(150, 0, 200, this.t);
                    ellipse(0, 0, this.s, this.s / rt3);
                    ctx.globalAlpha = 1;
                }

                ctx.lineWidth = 3;
                stroke(200, 0, 255);
                with(ctx){
                    beginPath();

                    let x = 0;
                    for(let i = 0; i < 400; i += 40){
                        x += -10 + 20 * Math.random();
                        lineTo(x, -i);
                    }

                    stroke();
                }

                ctx.lineWidth = 1;
                stroke(180, 0, 220);
                with(ctx){
                    beginPath();
                    moveTo(0, 0);

                    for(let i = 50; i < 400; i += 40){
                        lineTo(-25 + 50 * Math.random(), -i);
                    }

                    stroke();
                }

                ctx.restore();
            };
            Lightning.prototype.update = function(){
                if(this.timer === this.maxTime / 2){
                    this.dealDamage();
                }
                
                this.t -= 6;
                this.s = lerp(this.s, this.aoe * 2, 0.3);

                this.timer--;
                if(this.timer === 0){
                    this.on = false;
                }
            };
            Lightning.prototype.dealDamage = function(){

                // loop through all entities
                for(let i = 0; i < entities.length; i++){
                    let en = entities[i];

                    // only damage the player, castle, towers, and decoys
                    if(en.type !== "player" && en.type !== "castle" && en.type !== "tower" && en.type !== "decoy"){
                        continue;
                    }

                    // deal damage to the enemy if it's within range
                    if(distSQ(this.x, this.y, en.x, en.y) <= Math.pow(this.aoe, 2)){
                        en.health -= this.dmg;
                    }
                }
            };

        </script>

        <!-- coins and XP -->
        <script>
            var BronzeCoin = function(x, y, z){

                // whether or not it still exists
                this.on = true;

                // entity type
                this.type = "coin";

                // whether or not it can move
                this.mobile = true;

                // coordinates
                let r = 360 * Math.random(), d = 2 + 5 * Math.random();
                this.x = x + d * cos(r);
                this.y = y + d * sin(r);
                this.z = z;

                // diameter
                this.sz = 8;

                // worth
                this.value = 1;

                // time until despawn
                this.timer = 1000;

                // velocity
                this.vel = {
                    x: d * cos(r),
                    y: d * sin(r),
                    z: -5 - 5 * Math.random()
                };

                // angle of rotation
                this.r = 360 * Math.random();

                // acceleration due to gravity
                this.grav = 0.5;
            };
            BronzeCoin.prototype.draw = function(){

                ctx.save();
                ctx.translate(this.x, this.y / rt3 + this.z);

                fill(0, 20);
                ellipse(0, 0, this.sz, this.sz / rt3);

                fill(100, 50, 0);
                ellipse(0, -this.sz / 2, (this.sz + 2) * Math.abs(sin(this.r)), this.sz + 2);

                fill(200, 100, 0);
                ellipse(0, -this.sz / 2, this.sz * Math.abs(sin(this.r)), this.sz);

                ctx.restore();
            };
            BronzeCoin.prototype.update = function(){
                
                // if it hasn't yet hit the ground...
                if(this.z < 0){
                    this.vel.z += this.grav;
                    
                    this.x += this.vel.x;
                    this.y += this.vel.y;
                    this.z += this.vel.z;
                }

                // otherwise...
                else{
                    this.z = 0;

                    let dist = distSQ(this.x, this.y, player.x, player.y);
                    if(dist < Math.pow(100, 2)){
                        this.x = lerp(this.x, player.x, (1 - dist / Math.pow(100, 2)) / 2);
                        this.y = lerp(this.y, player.y, (1 - dist / Math.pow(100, 2)) / 2);
                    }

                    if(distSQ(this.x, this.y, player.x, player.y) < Math.pow(this.sz / 2 + player.sz / 2, 2)){
                        player.gold += this.value;
                        this.on = false;
                    }
                }

                // slowly spin around
                this.r += 5;
                this.r %= 360;
            };

            var SilverCoin = function(x, y, z){
                
                // whether or not it still exists
                this.on = true;

                // entity type
                this.type = "coin";

                // whether or not it can move
                this.mobile = true;

                // coordinates
                let r = 360 * Math.random(), d = 2 + 5 * Math.random();
                this.x = x + d * cos(r);
                this.y = y + d * sin(r);
                this.z = z;

                // diameter
                this.sz = 14;

                // worth
                this.value = 3;

                // time until despawn
                this.timer = 1000;

                // velocity
                this.vel = {
                    x: d * cos(r),
                    y: d * sin(r),
                    z: -5 - 5 * Math.random()
                };

                // angle of rotation
                this.r = 360 * Math.random();

                // acceleration due to gravity
                this.grav = 0.6;
            };
            SilverCoin.prototype.draw = function(){

                ctx.save();
                ctx.translate(this.x, this.y / rt3 + this.z);

                fill(0, 20);
                ellipse(0, 0, this.sz, this.sz / rt3);

                fill(120);
                ellipse(0, -this.sz / 2, (this.sz + 2) * Math.abs(sin(this.r)), this.sz + 2);

                fill(220);
                ellipse(0, -this.sz / 2, this.sz * Math.abs(sin(this.r)), this.sz);

                ctx.restore();
            };
            SilverCoin.prototype.update = function(){
                
                // if it hasn't yet hit the ground...
                if(this.z < 0){
                    this.vel.z += this.grav;
                    
                    this.x += this.vel.x;
                    this.y += this.vel.y;
                    this.z += this.vel.z;
                }

                // otherwise...
                else{
                    this.z = 0;

                    let dist = distSQ(this.x, this.y, player.x, player.y);
                    if(dist < Math.pow(100, 2)){
                        this.x = lerp(this.x, player.x, (1 - dist / Math.pow(100, 2)) / 2);
                        this.y = lerp(this.y, player.y, (1 - dist / Math.pow(100, 2)) / 2);
                    }

                    if(distSQ(this.x, this.y, player.x, player.y) < Math.pow(this.sz / 2 + player.sz / 2, 2)){
                        player.gold += this.value;
                        this.on = false;
                    }
                }

                // slowly spin around
                this.r += 3;
                this.r %= 360;
            };

            var GoldCoin = function(x, y, z){
 
                // whether or not it still exists
                this.on = true;

                // entity type
                this.type = "coin";

                // whether or not it can move
                this.mobile = true;

                // coordinates
                let r = 360 * Math.random(), d = 2 + 5 * Math.random();
                this.x = x + d * cos(r);
                this.y = y + d * sin(r);
                this.z = z;

                // diameter
                this.sz = 15;

                // worth
                this.value = 10;

                // time until despawn
                this.timer = 1000;

                // velocity
                this.vel = {
                    x: d * cos(r),
                    y: d * sin(r),
                    z: -5 - 5 * Math.random()
                };

                // angle of rotation
                this.r = 360 * Math.random();

                // acceleration due to gravity
                this.grav = 0.7;
            };
            GoldCoin.prototype.draw = function(){

                ctx.save();
                ctx.translate(this.x, this.y / rt3 + this.z);

                fill(0, 20);
                ellipse(0, 0, this.sz, this.sz / rt3);

                fill(150, 150, 0);
                ellipse(0, -this.sz / 2, (this.sz + 4) * Math.abs(sin(this.r)), this.sz + 4);

                fill(255, 255, 0);
                ellipse(0, -this.sz / 2, this.sz * Math.abs(sin(this.r)), this.sz);

                ctx.restore();
            };
            GoldCoin.prototype.update = function(){
                
                // if it hasn't yet hit the ground...
                if(this.z < 0){
                    this.vel.z += this.grav;
                    
                    this.x += this.vel.x;
                    this.y += this.vel.y;
                    this.z += this.vel.z;
                }

                // otherwise...
                else{
                    this.z = 0;

                    let dist = distSQ(this.x, this.y, player.x, player.y);
                    if(dist < Math.pow(100, 2)){
                        this.x = lerp(this.x, player.x, (1 - dist / Math.pow(100, 2)) / 2);
                        this.y = lerp(this.y, player.y, (1 - dist / Math.pow(100, 2)) / 2);
                    }

                    if(distSQ(this.x, this.y, player.x, player.y) < Math.pow(this.sz / 2 + player.sz / 2, 2)){
                        player.gold += this.value;
                        this.on = false;
                    }
                }

                // slowly spin around
                this.r += 2;
                this.r %= 360;
            };

            var addMoney = function(amt, x, y, z){
                for(let i = 0; i < amt;){
                    if(i <= amt - 10){
                        addEntity(new GoldCoin(x, y, z));
                        i += 10;
                    }

                    else if(i <= amt - 3){
                        addEntity(new SilverCoin(x, y, z));
                        i += 3;
                    }

                    else{
                        addEntity(new BronzeCoin(x, y, z));
                        i++;
                    }
                }
            };

            var XP = function(x, y, z, amt){
                
                // whether or not it still exists
                this.on = true;

                // entity type
                this.type = "xp";

                // coordinates
                this.x = x;
                this.y = y;
                this.z = z;

                // amount
                this.amt = amt;

                // transparency
                this.t = 255;

                // size
                this.s = 1;
            };
            XP.prototype.draw = function(){
                ctx.save();
                ctx.translate(this.x, this.y / rt3 + this.z);
                ctx.scale(this.s, this.s);

                fill(0, 100, 255, this.t);
                setFont(10);
                
                let m = (typeof this.amt === "number" ? "+" : "") + this.amt, tw = ctx.measureText(m).width;
                ctx.fillText(m, -tw / 2, 0);

                ctx.restore();
            };
            XP.prototype.update = function(){
                this.t -= 5;
                this.s += 0.05;
                this.z--;

                if(this.t <= 0){
                    this.on = false;
                }
            };
            
        </script> 

        <!-- castle -->
        <script>
            var castle = (function(){
                var Castle = function(){
                    
                    // entity type
                    this.type = "castle";

                    // it exists
                    this.on = true;

                    // coordinates
                    this.x = 0;
                    this.y = 0;

                    // velocity (always zero)
                    this.vel = {
                        x: 0,
                        y: 0
                    };

                    // diameter
                    this.sz = 150;

                    // stats
                    this.maxHealth = 500; // maximum health
                    this.health = this.maxHealth; // health
                    this.pHealth = this.health; // health from previous frame
                    
                };
                Castle.prototype.draw = function(){
                    ctx.save();
                    ctx.translate(this.x, this.y / rt3);

                    fill(100);
                    with(ctx){
                        beginPath();

                        moveTo(-100, -150);
                        lineTo(-50, -200);
                        lineTo(50, -200);
                        lineTo(100, -150);
                        lineTo(50, -100);
                        lineTo(-50, -100);

                        fill();
                    }

                    fill(150);
                    with(ctx){
                        beginPath();
                        
                        moveTo(-100, -150);
                        lineTo(-100, -200);
                        lineTo(-50, -250);
                        lineTo(50, -250);
                        lineTo(100, -200);
                        lineTo(100, -150);
                        lineTo(50, -200);
                        lineTo(-50, -200);

                        fill();
                    }

                    fill(0, 20);
                    with(ctx){
                        beginPath();

                        moveTo(-100, -150);
                        lineTo(-100, -200);
                        lineTo(-50, -250);
                        lineTo(-50, -200);

                        fill();
                    }

                    fill(0, 50);
                    with(ctx){
                        beginPath();

                        moveTo(100, -150);
                        lineTo(100, -200);
                        lineTo(50, -250);
                        lineTo(50, -200);

                        fill();
                    }

                    fill(150);
                    with(ctx){
                        beginPath();
                        
                        moveTo(-75, 0);
                        lineTo(-75, -100);
                        lineTo(-100, -150);
                        lineTo(-100, -200);

                        lineTo(-50, -150);
                        lineTo(50, -150);
                        lineTo(100, -200);

                        lineTo(100, -150);
                        lineTo(75, -100);
                        lineTo(75, 0);
                        
                        lineTo(37.5, 37.5);
                        lineTo(-37.5, 37.5);

                        fill();
                    }

                    fill(0, 50);
                    with(ctx){
                        beginPath();
                        
                        moveTo(-75, 0);
                        lineTo(-75, -100);
                        lineTo(-100, -150);
                        lineTo(-100, -200);

                        lineTo(-50, -150);
                        lineTo(-50, -100);
                        lineTo(-37.5, -75);
                        lineTo(-37.5, 37.5);

                        fill();
                    }

                    fill(0, 20);
                    with(ctx){
                        beginPath();
                        
                        moveTo(75, 0);
                        lineTo(75, -100);
                        lineTo(100, -150);
                        lineTo(100, -200);

                        lineTo(50, -150);
                        lineTo(50, -100);
                        lineTo(37.5, -75);
                        lineTo(37.5, 37.5);

                        fill();
                    }

                    fill(150, 0, 0);
                    with(ctx){
                        beginPath();

                        moveTo(-25, -150);
                        bezierCurveTo(-30, -130, -20, -80, -25, -50);
                        bezierCurveTo(-10, -70, -12, -80, 0, -100);
                        bezierCurveTo(12, -80, 10, -70, 25, -50);
                        bezierCurveTo(20, -80, 30, -130, 25, -150);

                        fill();
                    }

                    fill(150, 75, 0);
                    with(ctx){
                        beginPath();

                        moveTo(-20, 37.5);
                        arc(0, 0, 20, angle(180), angle(360));
                        lineTo(20, 37.5);

                        fill();
                    }

                    fill(180, 180, 0);
                    ellipse(15, 15, 7, 7);

                    // the health bar
                    fill(0);
                    ctx.fillRect(-100, -240, 200, 8);

                    if(this.health > 0){
                        fill(200, 0, 0);
                        ctx.fillRect(-100, -240, this.health * 200 / this.maxHealth, 8);
                    }

                    ctx.restore();
                };
                Castle.prototype.update = function(){
                    
                    // if it takes damage, shake the screen
                    if(this.health < this.pHealth){
                        shakeScreen(20);
                    }

                    // update pHealth
                    this.pHealth = this.health;
                    
                    // if it's health reaches zero, end the game
                    if(this.health <= 0){
                        shakeScreen(20);

                        trans.active = true;
                        trans.next = function(){
                            if(player.lvl > player.highScore){
                                player.highScore = player.lvl;
                            }

                            resetGame();
                        };
                    }
                };

                return new Castle();
            })();
        </script>
        
        <!-- player -->
        <script>
            var player = (function(){
                var Player = function(){

                    // entity type
                    this.type = "player";

                    // whether or not it can move
                    this.mobile = true;

                    // they exist
                    this.on = true;
                    
                    // coordinates
                    this.x = 0;
                    this.y = 200;

                    // coords from previous frame
                    this.px = 0;
                    this.py = 0;

                    // velocity
                    this.vel = {x: 0, y: 0};

                    // respawn point
                    this.startPos = {x: 0, y: tileSize * rt3 / 4};

                    // which direction they're facing
                    this.dir = {x: 0, y: 1};
                    this.r = 90;

                    // diameter
                    this.sz = 40;

                    // stats
                    this.maxSpeed = 7; // default movement speed
                    this.speed = this.maxSpeed; // speed
                    this.dmg = 30; // damage
                    this.range = 120; // attack range
                    this.xp = 0; // experience
                    this.lvl = 0; // levels of experience
                    this.gold = 0; // sweet, sweet cash
                    this.health = 100; // health
                    this.maxHealth = 100; // maximum health
                    this.regen = 0.25; // regen rate

                    // total XP needed to reach the next level (including any XP already obtained)
                    this.xpNeeded = function(lvl){
                        return lvl < 0 ? 0 : 25 + Math.pow(lvl, 1.8) * 75;
                    };

                    // the cost of building a tower
                    this.costOf = function(towerType){
                        return (
                            towerType === ArrowTower ? 50 :
                            towerType === BallistaTower ? 75 :
                            towerType === CannonTower ? 100 :
                            towerType === FreezeTower ? 150 :
                            0
                        );
                    };

                    // high score
                    this.highScore = 0;

                    // whether or not they're slowed
                    this.slowed = false;

                    // what they're doing
                    this.action = "stand";

                    // x- and y-translation
                    this.tx = 0;
                    this.ty = 0;

                    // right hand
                    this.hand1 = {
                        x: -25,
                        y: -5,
                        r: 70,

                        inFront: true
                    };

                    // left hand
                    this.hand2 = {
                        x: 20,
                        y: -10,

                        inFront: true
                    };

                    // sword slash
                    let t = this;
                    this.slash = {
                        r0: false,
                        r: 0,
                        count: 0,
                        draw: function(){
                            ctx.save();
                            ctx.translate(0, t.hand1.y);
                            ctx.scale(1, 1 / rt3);

                            fill(255, 50);
                            with(ctx){
                                beginPath();

                                moveTo(t.range * cos(this.r), t.range * sin(this.r));
                                arc(0, 0, t.range, angle(this.r), angle(this.r0), true);
                                /*
                                bezierCurveTo(
                                    50 * this.count * cos(this.r0 + (this.r - this.r0) / 3), 50 * this.count * sin(this.r0 + (this.r - this.r0) / 3),
                                    50 * this.count * cos(this.r0 + (this.r - this.r0) * 2 / 3), 50 * this.count * sin(this.r0 + (this.r - this.r0) * 2 / 3),
                                    0, 0
                                );
                                */
                                lineTo(0, 0);

                                fill();
                            }

                            ctx.globalAlpha = 1;

                            ctx.restore();
                        }
                    };

                    // control variables
                    this.l = false; // left
                    this.r = false; // right
                    this.u = false; // up
                    this.d = false; // down
                    this.a = false; // attack
                    this.pa = false; // was attacking last frame

                    // actions
                    this.stand = function(){

                        if(this.dir.x === -1){
                            this.hand1.x = -20;
                            this.hand1.y = -15;
                            this.hand1.r = -30;
                            this.hand1.inFront = false;
                            
                            this.hand2.x = 10;
                            this.hand2.y = -10;
                            this.hand2.inFront = true;
                        }

                        else if(this.dir.x === 1){
                            this.hand1.x = 20;
                            this.hand1.y = -5;
                            this.hand1.r = 30;
                            this.hand1.inFront = true;

                            this.hand2.x = -10;
                            this.hand2.y = -10;
                            this.hand2.inFront = false;
                        }

                        else if(this.dir.y === -1){
                            this.hand1.x = 20;
                            this.hand1.y = -10;
                            this.hand1.r = -50;
                            this.hand1.inFront = false;

                            this.hand2.x = -20;
                            this.hand2.y = -15;
                            this.hand2.inFront = false;
                        }

                        else if(this.dir.y === 1){
                            this.hand1.x = -25;
                            this.hand1.y = -5;
                            this.hand1.r = 70;
                            this.hand1.inFront = true;

                            this.hand2.x = 20;
                            this.hand2.y = -10;
                            this.hand2.inFront = true;
                        }

                        this.slash.r0 = false;
                        this.slash.r = 0;
                        this.slash.count = 0;

                    };
                    this.attack = function(){

                        if(this.slash.r0 === false){
                            this.slash.r0 = (
                                this.dir.x === 1 ? 0 :
                                this.dir.x === -1 ? 180 :
                                this.dir.y === 1 ? 90 :
                                270
                            );
                        }

                        if(this.slash.r - this.slash.r0 > 360){
                            this.dealDamage();
                            this.action = "stand";
                        }

                        else{
                            this.slash.count++;
                        }
                        
                        this.slash.r = (this.slash.r0 + this.slash.count * 30);
                        
                        this.hand1.r = this.slash.r + 90;
                        this.hand1.inFront = (this.slash.r % 360 <= 180);

                        this.hand1.x = 40 * cos(this.slash.r);
                    };
                    
                    // tower-building icons
                    this.towerButtons = (function(){
                        let array = [];

                        let TowerButton = function(x, y, towerType, lvlReq, key, img){

                            // coordinates
                            this.x = x;
                            this.y = y;

                            // type of tower to build
                            this.towerType = towerType;

                            // how many levels the player needs to unlock this tower type
                            this.lvlReq = lvlReq;

                            // key to press to activate
                            this.key = key;

                            // image to draw on top
                            this.img = img;

                            // width and height of the button
                            this.sz = 50;

                            // how long the user has to hold down the appropriate key
                            this.totalTime = 60; // total duration
                            this.timer = this.totalTime; // current time left

                            // tower progress so far
                            this.progress = 0;

                        };
                        TowerButton.prototype.draw = function(){
                            ctx.save();
                            ctx.translate(this.x, this.y);

                            let frac = player.gold >= player.costOf(this.towerType) ? this.timer / this.totalTime : 0;

                            let grd = ctx.createLinearGradient(0, -this.sz / 2, 0, this.sz / 2);
                            grd.addColorStop(0, color(200));
                            grd.addColorStop(frac, color(200));
                            grd.addColorStop(frac, color(100));
                            grd.addColorStop(1, color(100));

                            ctx.globalAlpha = 0.5;
                            ctx.fillStyle = grd;

                            with(ctx){
                                beginPath();

                                moveTo(-this.sz / 2, -this.sz / 2 + 5);
                                arc(-this.sz / 2 + 5, -this.sz / 2 + 5, 5, angle(180), angle(270));
                                arc(this.sz / 2 - 5, -this.sz / 2 + 5, 5, angle(270), angle(360));
                                arc(this.sz / 2 - 5, this.sz / 2 - 5, 5, 0, angle(90));
                                arc(-this.sz / 2 + 5, this.sz / 2 - 5, 5, angle(90), angle(180));

                                fill();
                            }

                            ctx.globalAlpha = 1;

                            fill(0);
                            setFont(15);
                            ctx.fillText(this.key - 48, -this.sz / 2 + 5, -this.sz / 2 + 15);

                            this.img();

                            let m = player.costOf(this.towerType), tw = ctx.measureText(m).width;
                            fill(player.gold >= m ? color(255, 255, 0) : color(200, 200, 50));
                            ctx.fillText(m, this.sz / 2 - 5 - tw, this.sz / 2 - 5);

                            ctx.restore();
                        };
                        TowerButton.prototype.update = function(){
                            
                            let mapPos = findMapPos(player.x, player.y),
                                buildPos = findCoords(mapPos.j, mapPos.i);
                            
                            if(keys[this.key] && player.health > 0 && player.gold >= player.costOf(this.towerType) && gameMap[mapPos.i][mapPos.j] !== "1"){
                                if(this.timer === this.totalTime){
                                    this.progress = new InProgressTower(buildPos.x, buildPos.y, this.towerType);
                                    addEntity(this.progress);
                                }

                                if(this.timer <= this.totalTime / 2){
                                    this.progress.stage = 1;
                                }
                                
                                this.timer--;
                            }

                            else{
                                if(this.progress){
                                    this.progress.on = false;
                                    this.progress = false;
                                }

                                this.timer = this.totalTime;
                            }

                            if(this.timer === 0){

                                addEntity(new this.towerType(buildPos.x, buildPos.y));
                                gameMap[mapPos.i] = gameMap[mapPos.i].slice(0, mapPos.j) + "1" + gameMap[mapPos.i].slice(mapPos.j + 1, gameMap[mapPos.i].length);
                                player.gold -= player.costOf(this.towerType);

                                this.progress.on = false;
                                this.progress = false;

                                this.timer = this.totalTime;
                            }
                        };

                        array.push(new TowerButton(35, height - 35, ArrowTower, 1, 49, function(){
                            ctx.save();
                            ctx.translate(12, -12);
                            ctx.rotate(angle(-45));

                            // the shaft
                            fill(100, 50, 0);
                            ctx.fillRect(-30, -1, 25, 2);

                            // the head and tail
                            fill(0, this.t);
                            with(ctx){
                                beginPath();

                                moveTo(0, 0);
                                lineTo(-5, -2);
                                lineTo(-5, 2);

                                moveTo(-25, 0);
                                lineTo(-27, -2);
                                lineTo(-32, -2);
                                lineTo(-30, 0);
                                lineTo(-32, 2);
                                lineTo(-27, 2);

                                fill();
                            }

                            ctx.restore();
                        }));
                        array.push(new TowerButton(95, height - 35, BallistaTower, 2, 50, function(){
                            ctx.save();
                            ctx.translate(15, -15);
                            ctx.rotate(angle(-45));
                            ctx.scale(0.8, 0.8);

                            // the shaft
                            fill(0);
                            ctx.fillRect(-50, -1.5, 40, 3);

                            // the head and tail
                            fill(0);
                            with(ctx){
                                beginPath();

                                moveTo(0, 0);
                                lineTo(-10, -4);
                                lineTo(-10, 4);

                                moveTo(-40, 0);
                                lineTo(-45, -5);
                                lineTo(-55, -5);
                                lineTo(-50, 0);
                                lineTo(-55, 5);
                                lineTo(-45, 5);

                                fill();
                            }

                            ctx.restore();
                        }));
                        array.push(new TowerButton(155, height - 35, CannonTower, 4, 51, function(){
                            ctx.save();
                            ctx.rotate(angle(30));

                            fill(50);
                            ellipse(0, 5, 20, 20);
                            ctx.fillRect(-5, -7, 10, 5);

                            stroke(0);
                            with(ctx){
                                beginPath();

                                moveTo(0, -7);
                                bezierCurveTo(-2, -10, 8, -12, 0, -15);

                                stroke();
                            }

                            ctx.restore();
                        }));
                        array.push(new TowerButton(215, height - 35, FreezeTower, 6, 52, function(){
                            ctx.save();
                            ctx.scale(0.75, 0.75);

                            freezeIcon(0, 0);

                            ctx.restore();
                        }));

                        return array;
                    })();

                };
                Player.prototype.draw = function(){
                    ctx.save();
                    ctx.translate(this.x, this.y / rt3);

                    // shadow
                    fill(0, 100);
                    ellipse(0, 0, 40, 40 / rt3);

                    ctx.translate(this.tx, this.ty);

                    // sword slash
                    this.slash.draw();

                    // right hand
                    if(!this.hand1.inFront){
                        ctx.save();
                        ctx.translate(this.hand1.x, this.hand1.y);
                        ctx.rotate(angle(this.hand1.r));

                        fill(180);
                        with(ctx){
                            beginPath();

                            moveTo(-3, 0);
                            bezierCurveTo(-3, -20, -3, -60, 0, -70);
                            bezierCurveTo(3, -60, 3, -20, 3, 0);

                            fill();
                        }

                        fill(145, 121, 60);
                        ellipse(0, 0, 12, 12);

                        fill(100, 50, 0);
                        ellipse(-5, -6, 4, 4);
                        ellipse(5, -6, 4, 4);
                        ctx.fillRect(-5, -8, 10, 4);

                        ctx.restore();
                    }

                    // left hand
                    if(!this.hand2.inFront){
                        fill(145, 121, 60);
                        ellipse(this.hand2.x, this.hand2.y, 12, 12);
                    }

                    // body
                    fill(145, 121, 60);
                    ellipse(0, -20, 40, 40);

                    // eyes
                    fill(0);

                    if(this.dir.x === -1){
                        ellipse(-10, -25, 3, 3);
                    }

                    else if(this.dir.x === 1){
                        ellipse(10, -25, 3, 3);
                    }

                    else if(this.dir.y === 1){
                        ellipse(-6, -25, 3, 3);
                        ellipse(6, -25, 3, 3);
                    }

                    // clothes
                    fill(150, 0, 0);
                    with(ctx){
                        beginPath();

                        moveTo(0, -20);
                        arc(0, -20, 20, angle(180), 0, true);
                        bezierCurveTo(8, -12, -8, -12, -20, -20);

                        fill();
                    }

                    // crown
                    fill(200, 200, 0);
                    with(ctx){
                        beginPath();

                        moveTo(-12, -35);
                        lineTo(-12, -50);
                        bezierCurveTo(-7, -40, -5, -40, 0, -50);
                        bezierCurveTo(5, -40, 7, -40, 12, -50);
                        lineTo(12, -35);
                        bezierCurveTo(5, -32, -5, -32, -12, -35);

                        fill();
                    }

                    ellipse(-12, -50, 5, 5);
                    ellipse(0, -50, 5, 5);
                    ellipse(12, -50, 5, 5);

                    // right hand
                    if(this.hand1.inFront){
                        ctx.save();
                        ctx.translate(this.hand1.x, this.hand1.y);
                        ctx.rotate(angle(this.hand1.r));

                        fill(180);
                        with(ctx){
                            beginPath();

                            moveTo(-3, 0);
                            bezierCurveTo(-3, -20, -3, -60, 0, -70);
                            bezierCurveTo(3, -60, 3, -20, 3, 0);

                            fill();
                        }

                        fill(145, 121, 60);
                        ellipse(0, 0, 12, 12);

                        fill(100, 50, 0);
                        ellipse(-5, -6, 4, 4);
                        ellipse(5, -6, 4, 4);
                        ctx.fillRect(-5, -8, 10, 4);

                        ctx.restore();
                    }

                    // left hand
                    if(this.hand2.inFront){
                        fill(145, 121, 60);
                        ellipse(this.hand2.x, this.hand2.y, 12, 12);
                    }

                    // health bar
                    fill(0);
                    ctx.fillRect(-25, -70, 50, 3);

                    fill(200, 0, 0);
                    if(this.health > 0){
                        ctx.fillRect(-25, -70, this.health * 50 / this.maxHealth, 3);
                    }

                    // frozen icon
                    if(this.frozen){
                        freezeIcon(0, -this.sz * 2.5);
                    }

                    ctx.restore();
                };
                Player.prototype.update = function(){
                    
                    // being frozen
                    if(this.frozen > 0){
                        this.speed = this.maxSpeed / 2;
                        this.frozen--;
                    }

                    else{
                        this.speed = this.maxSpeed;
                    }

                    // attacking
                    if(this.action === "stand" && this.a && !this.pa){
                        this.action = "attack";
                    }

                    // move when the arrow keys are pressed and the player is not building a tower
                    let mapPos = findMapPos(this.x, this.y);
                    if(
                        (this.l || this.r || this.u || this.d) &&
                        (
                            (!keys[49] && !keys[50] && !keys[51] && !keys[52] && !keys[53] && !keys[54] && !keys[55] && !keys[56] && !keys[57] && !keys[58]) ||
                            gameMap[mapPos.i][mapPos.j] === "1"
                        )
                    ){
                        this.dir.x = this.r ? 1 : this.l ? -1 : 0;
                        this.dir.y = this.d ? 1 : this.u ? -1 : 0;

                        this.vel.x = this.dir.y === 0 ? this.dir.x * this.speed : this.dir.x * this.speed / rt2;
                        this.vel.y = this.dir.x === 0 ? this.dir.y * this.speed : this.dir.y * this.speed / rt2;

                        this.r = atan2(this.dir.y, this.dir.x);
                    }

                    // otherwise, stand still
                    else{
                        this.vel.x = 0;
                        this.vel.y = 0;
                    }

                    // update previous coordinates
                    this.px = this.x;
                    this.py = this.y;

                    // update coordinates
                    this.x += this.vel.x;
                    this.y += this.vel.y;

                    // constrain coordinates to keep the player inside the map
                    let mapSize = (gameMap.length - 1) / 2;
                    this.x = constrain(this.x, -tileSize * 0.75 * mapSize + this.sz / 2, tileSize * 0.75 * mapSize - this.sz / 2);
                    this.y = constrain(this.y, -tileSize * rt3 / 2 * mapSize + this.sz / 2, tileSize * rt3 / 2 * (mapSize + 0.5) - this.sz / 2);

                    // execute action
                    this[this.action]();

                    // levelling up
                    if(this.xp >= this.xpNeeded(this.lvl)){
                        this.lvl++;
                        addEntity(new XP(this.x, this.y, -this.sz * 2, "Level up!"));

                        // increase max health
                        let ratio = this.health / this.maxHealth;
                        this.maxHealth += 20;
                        this.health = this.maxHealth * ratio;

                        // increase max speed
                        this.maxSpeed += 0.25;
                    }

                    // dying and respawning
                    if(this.health <= 0){
                        let t = this;

                        trans.active = true;
                        trans.next = function(){
                            t.health = t.maxHealth;

                            t.x = t.startPos.x;
                            t.y = t.startPos.y;

                            t.score -= 100;
                        }
                    }

                    // regen
                    if(this.health < this.maxHealth){
                        this.health += this.regen;
                    }

                };
                Player.prototype.dealDamage = function(){
                    
                    // loop through all entities
                    for(let i = 0; i < entities.length; i++){
                        let en = entities[i];

                        // only damage enemies
                        if(en.type !== "enemy"){
                            continue;
                        }

                        // deal damage to the enemy if it's within range
                        if(distSQ(this.x, this.y, en.x, en.y) <= Math.pow(this.range, 2)){
                            en.health -= this.dmg;
                        }
                    }
                };
                Player.prototype.UI = function(){
                    
                    // tower-building icons
                    for(let i = 0; i < this.towerButtons.length; i++){
                        let tb = this.towerButtons[i];

                        if(isResize){
                            tb.y = height - 35;
                        }

                        if(player.lvl >= tb.lvlReq){
                            if(!gamePaused){
                                tb.update();
                            }
                            
                            tb.draw();
                        }
                    }

                    // XP bar
                    stroke(0, 20, 100);
                    fill(255, 50);
                    with(ctx){
                        beginPath();

                        moveTo(45, 27);
                        arc(195, 30, 3, angle(270), angle(450));
                        lineTo(45, 33);

                        fill();

                        ctx.globalAlpha = 1;
                        stroke();
                    }

                    let barLength = (this.xp - this.xpNeeded(this.lvl - 1)) * 150 / (this.xpNeeded(this.lvl) - this.xpNeeded(this.lvl - 1));

                    fill(0, 100, 255);
                    ctx.fillRect(45, 28, barLength, 4);
                    ellipse(45 + barLength, 30, 4, 4);

                    fill(0, 50, 150);
                    ellipse(30, 30, 40, 40);

                    fill(0, 100, 255);
                    ellipse(30, 30, 38, 38);

                    fill(0);
                    setFont(12);
                    let m = "Lvl. " + this.lvl, tw = ctx.measureText(m).width;
                    ctx.fillText(m, 30 - tw / 2, 33);

                    // gold
                    let sz = 8;

                    ctx.save();
                    ctx.translate(20, 80);

                    fill(150, 150, 0);
                    ellipse(0, -sz / 2, (sz + 2) * Math.abs(sin(frameCount * 5)), sz + 2);

                    fill(255, 255, 0);
                    ellipse(0, -sz / 2, sz * Math.abs(sin(frameCount * 5)), sz);

                    ctx.restore();

                    ctx.lineWidth = 2;
                    stroke(150, 150, 0);
                    fill(255, 255, 0);
                    setFont(15);

                    ctx.strokeText(player.gold, 30, 81);
                    ctx.fillText(player.gold, 30, 81);

                    ctx.lineWidth = 1;

                };
                Player.prototype.control = function(){
                    this.pa = this.a;
                    
                    this.l = keys[LEFT] || keys[A];
                    this.r = keys[RIGHT] || keys[D];
                    this.u = keys[UP] || keys[W];
                    this.d = keys[DOWN] || keys[S];
                    this.a = keys[SPACE];
                };

                return new Player();
            })();
        </script>

        <!-- entity management -->
        <script>

            // a global array of all entites currently in the game
            var entities = [player, castle];

            // adds a new entity to the beginning of the list (so that it doesn't get updated until the next loop)
            var addEntity = function(entity){
                entities.splice(0, 0, entity);
            };

            // checks for and implements collisions between two entities
            var collideEntities = function(e1, e2){

                // don't collide if one of the entities is condemned to be removed
                if(!e1.on || !e2.on){
                    return;
                }
                
                // missiles and xp don't collide in the normal way
                if(e1.type === "missile" || e2.type === "missile" || e1.type === "xp" || e2.type === "xp"){
                    return;
                }

                // if the entities are too close together...
                let distSquared = distSQ(e1.x, e1.y, e2.x, e2.y);
                if(distSquared < Math.pow(e1.sz / 2 + e2.sz / 2, 2)){
                    
                    // get the angle between them
                    let theta = atan2(e2.y - e1.y, e2.x - e1.x);

                    // calculate how much further apart they should be
                    let dist = e1.sz / 2 + e2.sz / 2 - Math.sqrt(distSquared);

                    // push them apart
                    if(e1.mobile === e2.mobile){
                        e1.x -= dist / 2 * cos(theta);
                        e1.y -= dist / 2 * sin(theta);

                        e2.x += dist / 2 * cos(theta);
                        e2.y += dist / 2 * sin(theta);
                    }

                    else if(!e1.mobile){
                        e2.x += dist * cos(theta);
                        e2.y += dist * sin(theta);
                    }

                    else if(!e2.mobile){
                        e1.x -= dist * cos(theta);
                        e1.y -= dist * sin(theta);
                    }

                }
            };

            // updates and draws all entities and removes any necessary
            var displayEntities = function(){
                
                // sort entities by y-coordinate
                if(!delag || frameCount % 10 === 0){
                    entities.sort(function(a, b){ return a.y - b.y; });
                }

                // loop through all entities
                for(let i = 0; i < entities.length; i++){
                    let en = entities[i];

                    // if it's a coin, update timer (regardless of whether or not we're calling en.update())
                    if(en.type === "coin"){
                        en.timer--;
                        if(en.timer === 0){
                            en.on = false;
                        }
                    }

                    // remove any entity that is no longer needed
                    if(!en.on){
                        entities.splice(i, 1);
                        i--;

                        continue;
                    }

                    // don't bother with coins if they're off the screen
                    if(en.type === "coin" && Math.abs(en.x - player.x) > (width / 2 + 50) * scaleFactor && Math.abs(en.y - player.y) > (height / 2 + 50) * scaleFactor){
                        continue;
                    }

                    // only update in real time if the game is in progress
                    if(gameStarted && (!gamePaused || en.type === "coin" || en.type === "xp")){

                        // update the entity
                        if(en.type !== "player"){ // player is updated separately
                            en.update();
                        }

                        // check for collisions
                        for(let j = i; j < entities.length; j++){
                            collideEntities(en, entities[j]);
                        }

                    }
                    
                    // draw the entity on the canvas
                    en.draw();
                }
            };

        </script>

        <!-- title -->
        <script>
            var drawTitle = function(){
                
                // letter stroke width
                let sw = 25;

                let H = function(x, y){
                    with(ctx){
                        save();
                        translate(x, y);

                        /*
                        beginPath();

                        moveTo(-tileSize / 4, -tileSize / 4);
                        lineTo(-tileSize / 2, 0);
                        lineTo(-tileSize / 4, tileSize / 4);

                        lineTo(-tileSize / 4 + 2 * sw / rt3, tileSize / 4);
                        lineTo(-tileSize / 2 + 2 * sw / rt3, 0);
                        lineTo(-tileSize / 4 + 2 * sw / rt3, -tileSize / 4);

                        fill();

                        beginPath();

                        moveTo(tileSize / 4, -tileSize / 4);
                        lineTo(tileSize / 2, 0);
                        lineTo(tileSize / 4, tileSize / 4);

                        lineTo(tileSize / 4 - 2 * sw / rt3, tileSize / 4);
                        lineTo(tileSize / 2 - 2 * sw / rt3, 0);
                        lineTo(tileSize / 4 - 2 * sw / rt3, -tileSize / 4);

                        fill();

                        ctx.fillRect(-tileSize / 2 + 2 * sw / rt3, -sw / 2 / rt3, tileSize - 4 * sw / rt3, sw / rt3);
                        */

                        ctx.fillRect(-tileSize / 4, -tileSize / 4, sw, tileSize / 2);
                        ctx.fillRect(tileSize / 4 - sw, -tileSize / 4, sw, tileSize / 2);
                        ctx.fillRect(-tileSize / 4 + sw, -sw / 2, tileSize / 2 - sw * 2, sw / rt3);

                        restore();
                    }
                };
                let E = function(x, y){
                    with(ctx){
                        save();
                        translate(x, y);
                        
                        beginPath();

                        moveTo(-tileSize / 4, -tileSize / 4);
                        lineTo(-tileSize / 2, 0);
                        lineTo(-tileSize / 4, tileSize / 4);

                        lineTo(-tileSize / 4 + 2 * sw / rt3, tileSize / 4);
                        lineTo(-tileSize / 2 + 2 * sw / rt3, 0);
                        lineTo(-tileSize / 4 + 2 * sw / rt3, -tileSize / 4);

                        fill();

                        beginPath();

                        moveTo(-tileSize / 4, -tileSize / 4);
                        lineTo(-tileSize / 4 - sw / rt3, -tileSize / 4 + sw / rt3);
                        lineTo(tileSize / 4 + sw / rt3, -tileSize / 4 + sw / rt3);
                        lineTo(tileSize / 4, -tileSize / 4);

                        fill();

                        beginPath();

                        moveTo(-tileSize / 4, tileSize / 4);
                        lineTo(-tileSize / 4 - sw / rt3, tileSize / 4 - sw / rt3);
                        lineTo(tileSize / 4 + sw / rt3, tileSize / 4 - sw / rt3);
                        lineTo(tileSize / 4, tileSize / 4);

                        fill();

                        ctx.fillRect(-tileSize / 2 + 2 * sw / rt3, -sw / 2 / rt3, tileSize / 2 - 2 * sw / rt3, sw / rt3);

                        restore();
                    }
                };
                let X = function(x, y){
                    with(ctx){
                        save();
                        translate(x, y);

                        beginPath();

                        moveTo(-tileSize / 4, -tileSize / 4);
                        lineTo(tileSize / 4 - 2 * sw / rt3, tileSize / 4);
                        lineTo(tileSize / 4, tileSize / 4);
                        lineTo(-tileSize / 4 + 2 * sw / rt3, -tileSize / 4);

                        fill();

                        beginPath();

                        moveTo(tileSize / 4, -tileSize / 4);
                        lineTo(-tileSize / 4 + 2 * sw / rt3, tileSize / 4);
                        lineTo(-tileSize / 4, tileSize / 4);
                        lineTo(tileSize / 4 - 2 * sw / rt3, -tileSize / 4);

                        fill();

                        restore();
                    }
                };

                fill(Math.round(50 * (1 - titleFade)), Math.round(150 * (1 - titleFade)), Math.round(50 * (1 - titleFade)));

                H(-tileSize * 0.75, tileSize * 0.75);
                E(0, tileSize);
                X(tileSize * 0.75, tileSize * 0.75);

                setFont(30);
                let m = "C L I C K   T O   B E G I N", tw = ctx.measureText(m).width;
                ctx.fillText(m, -tw / 2, tileSize * 1.5 + 10);

                setFont(20);
                m = "High Score: " + player.highScore, tw = ctx.measureText(m).width;
                ctx.fillText(m, -tw / 2, tileSize * 1.5 + 40);

            };
        </script>
        
        <!-- scenes -->
        <script>

            // initialize the game
            resetGame();
            
            // scene transitions
            var trans = {
                active: false, // whether or not a transition is happening
                size: 0, // how far we are through the transition (0-510)
                next: function(){}, // what to do in the middle of the transition
                isNext: false // if the middle of the transition has happened yet
            };
            var changeScene = function(){
                
                // if there's a transition happening...
                if(trans.active){
                    
                    // increment trans.size
                    trans.size += 20;
                    
                    // if we're still in the first half, fade in
                    if(trans.size < 255){
                        fill(0, trans.size);
                    }
                    
                    // if we're in the second half...
                    else if(trans.size < 510){
                        // fade out
                        fill(0, 510 - trans.size);
                        
                        // if trans.next is a function, call it
                        if(typeof trans.next === "function" && !trans.isNext){
                            trans.next();
                        }
                        
                        // the middle of the transition is passed; so set trans.isNext to true
                        trans.isNext = true;
                    }
                    
                    // if the transition is finished...
                    else{
                        // remove the white over the top
                        fill(0, 0);
                        
                        // reset variables for next transition
                        trans.active = false;
                        trans.size = 0;
                        trans.isNext = false;
                    }
                    
                    // draw the white rectangle overtop everything else
                    ctx.fillRect(0, 0, width, height);
                    
                    // set globalAlpha to 1 so tranparency doesn't affect other graphics
                    ctx.globalAlpha = 1;
                }
            };

            // draws the current scene
            var drawScene = function(){

                // screen shake
                if(Math.abs(shakeX) > 1){
                    shakeX = lerp(shakeX, 0, 1.75);
                }else{
                    shakeX = 0;
                }

                // start game
                if(!gameStarted){
                    mouseClicked = function(){
                        gameStarted = true;
                    };
                }
                
                // background
                fill(0);
                ctx.fillRect(0, 0, width, height);

                // update the player before translating the screen to their coordinates for smoother motion
                if(gameStarted && !gamePaused){
                    player.control();
                    player.update();
                }

                ctx.save();
                ctx.translate(width / 2 + shakeX, height / 2);
                ctx.scale(1 / scaleFactor, 1 / scaleFactor);
                ctx.translate(-player.x, -player.y / rt3);

                // map
                drawMap();

                if(titleFade > 0){
                    drawTitle();
                }

                // update and draw entities
                if(gameStarted && !gamePaused && enemySpawn){
                    spawnEnemies();
                }

                displayEntities();

                ctx.restore();

                // tutorial
                if(gameStarted){
                    tutorial();
                }

                // XP bar and coins
                player.UI();

                // full screen button
                if(width < 800 && titleFade > 0){
                    fullScreenBtn();
                }
                
                // pause button
                if(gameStarted){
                    pauseBtn();
                }

                // slow down entity sorting if frame rate gets too low
                if(FPS < 40){
                    delag = true;
                }

                // fade out the title
                if(gameStarted){

                    if(titleFade > 0.05){
                        titleFade = lerp(titleFade, 0, 0.1);
                    }

                    else{
                        titleFade = 0;
                    }
                }

                // scene transitions
                changeScene();
            };
        </script>
        
        <!-- animation loop -->
        <script>

            // function to be called each frame
            var animate = function(){
                
                // reset mouseClicked
                if(mouseClicked){ mouseClicked = function(){}; }

                // reset transform
                ctx.resetTransform();
                
                // draw the current scene
                drawScene();

                // reset pressed
                pressed = [];

                // reset isResize
                isResize = false;

                // calculate frame rate
                frameTimes.push(new Date().getTime());
                
                if(frameTimes.length > 100){
                    frameTimes.splice(0, 1);
                }
                
                FPS = 1000 * frameTimes.length / (frameTimes[frameTimes.length - 1] - frameTimes[0]);
            };
            
            // how many frames we've done so far
			var frameCount = 0;
			
			// target frame rate in fps
			var frameRate = 60;
            
            // actual frame rate
            var FPS = 60;
			
			// timestamp for each of the last few frames
			var frameTimes = [new Date().getTime()];

            // slows down entity sorting if the framerate gets too low
            var delag = false;
			
			// call animate() each frame
			setInterval(function() {
                frameCount++;
                animate()
            }, 1000 / frameRate);
        </script>
    </head>
    
    <!-- body tag, with lots of event listeners -->
    <body onkeydown="keyPressed(event)" onkeyup="keyReleased(event)" onclick="onClick(event)" onmousemove="updateMouse(event)" onmousedown="(function(){ mouseIsPressed = true; })()" onmouseup="(function(){ mouseIsPressed = false; })()" onresize="onResize()"></body>
    
</html>


